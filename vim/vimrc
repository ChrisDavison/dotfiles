" vim: set foldmethod=marker foldlevel=2:
" ChrisDavison's VIMRC {{{ 
" ============================================================================
set nocompatible
syntax on
filetype plugin indent on
let mapleader="\\"
set autochdir
let s:darwin = has('mac')
" }}}
" ============================================================================
" SETTINGS {{{ 
" ============================================================================
"-- Good defaults 
set nocompatible
syntax on
filetype plugin indent on
set encoding=utf-8
scriptencoding utf-8
set showcmd
set wrap lbr
set showbreak=⇇
set omnifunc=syntaxcomplete#Complete
set number
set iskeyword=a-z,A-Z,_,.,39
set hidden
set viminfo='10,<50,s10,%,h,n~/.viminfo
set nospell
set relativenumber
set shell=/bin/zsh
set foldenable " Don't fold by default
set foldlevelstart=1

"-- Search options 
set incsearch " Search as you type
set gdefault " By default, replace all matches on a line (i.e. always s///g)
set hlsearch " Highlight search results
set ignorecase
set smartcase
set magic
set backspace=indent,eol,start

"-- Various coding preferences 
set tabstop=4
set softtabstop=4
set shiftwidth=4
set expandtab
set autoread
set clipboard=unnamed
set lazyredraw
set laststatus=2
set nrformats=
set title
set sidescrolloff=15
set sidescroll=1

"-- Put all temp files in one place 
set backup
set backupcopy=yes
set backupdir=~/.backup,.
set directory=~/.temp,.

"-- Wildmenu config 
set wildmenu
set wildmode=list:longest

"""" Ignore certain files and directories in Wildmenu
set wildignore=*.o,*.obj,*~ 
set wildignore+=*vim/backups*
set wildignore+=*sass-cache*
set wildignore+=*DS_Store*
set wildignore+=vendor/rails/**
set wildignore+=vendor/cache/**
set wildignore+=*.gem
set wildignore+=log/**
set wildignore+=tmp/**
set wildignore+=*.png,*.jpg,*.gif

" }}}
" ============================================================================
" PLUGINS {{{ 
" ============================================================================
call plug#begin('~/.vim/plugged')

" Languages
Plug 'fatih/vim-go'
Plug 'pangloss/vim-javascript'
Plug 'racer-rust/vim-racer'
Plug 'plasticboy/vim-markdown'
Plug 'rbonvall/snipmate-snippets-bib'

" Utility
Plug 'mattn/webapi-vim'
Plug 'mattn/gist-vim'
Plug 'shime/vim-livedown'
Plug 'airblade/vim-gitgutter'
Plug 'tpope/vim-fugitive'
Plug 'Konfekt/FastFold'
Plug 'MarcWeber/vim-addon-mw-utils'
Plug 'dahu/vim-fanfingtastic'
Plug 'easymotion/vim-easymotion'
Plug 'ervandew/supertab'
Plug 'garbas/vim-snipmate'
Plug 'godlygeek/tabular'
Plug 'guns/vim-sexp'
Plug 'honza/vim-snippets'
Plug 'junegunn/fzf', { 'dir': '~/.fzf', 'do': './install --all' }
Plug 'junegunn/fzf.vim'
Plug 'junegunn/rainbow_parentheses.vim'
Plug 'kien/ctrlp.vim'
Plug 'lervag/vimtex'
Plug 'majutsushi/tagbar'
Plug 'nvie/vim-flake8'
Plug 'rking/ag.vim'
Plug 'scrooloose/syntastic'
Plug 'tacahiroy/ctrlp-funky'
Plug 'terryma/vim-expand-region'
Plug 'tomtom/tlib_vim'
Plug 'tpope/vim-commentary'
Plug 'tpope/vim-dispatch'
Plug 'tpope/vim-sensible'
Plug 'tpope/vim-speeddating'
Plug 'tpope/vim-surround'
Plug 'tpope/vim-unimpaired'
Plug 'tpope/vim-vinegar'
Plug 'vim-scripts/a.vim'
Plug 'vim-scripts/utl.vim'
Plug 'wellle/targets.vim'
Plug 'jpalardy/vim-slime'

" Plugins I'm currently *not* using
" Distraction-free writing
if 1
    Plug 'junegunn/goyo.vim'
    Plug 'junegunn/limelight.vim'
endif

" Lispy stuff
if 0
    Plug 'jpalardy/vim-slime'
    Plug 'tpope/vim-sexp-mappings-for-regular-people'
endif

" Utility
if 0
    Plug 'mattn/emmet-vim'
    Plug 'dhruvasagar/vim-table-mode'
endif

call plug#end()

" }}}
" ============================================================================
" APPEARANCE {{{ 
" ============================================================================
" Using theme variables to facilitate a light-dark toggle function
let g:cd_theme_mode = 'DARK'
let g:cd_light_theme = 'solarized'
let g:cd_dark_theme = 'solarized'

if has('gui')
    set encoding=utf-8
    set bg=dark
    execute 'colorscheme ' g:cd_dark_theme
    set guifont=Iosevka:h18,Input_Mono:h18
    
    " Disable menu bollocks
    set guioptions-=m
    set guioptions-=T
    set guioptions-=r
    set guioptions-=R
    set guioptions-=L
    set guioptions-=l
else
    set bg=dark
    let g:cd_dark_theme='paramount'
    let g:cd_light_theme='github'
    execute 'colorscheme ' g:cd_dark_theme
    set t_ut=
endif

"-- Highlight long rows ----- 
highlight ColorColumn ctermbg=magenta
call matchadd('ColorColumn', '\%81v', 100)

" }}}
" ============================================================================
" ABBREVIATIONS {{{ 
" ============================================================================
" Useful abbreviations
cnoreabbrev E e
cnoreabbrev W w
cnoreabbrev WQ wq
cnoreabbrev Q q
cnoreabbrev QA qa

iabbrev @@ c.jr.davison@gmail.com
iabbrev TD **TODO**
iabbrev EX **EXAMPLE:**
iabbrev E: Explain:
iabbrev Q? **Q?** 
iabbrev ACT **ACTION:**
iabbrev ASM *Assume* :: 
iabbrev T4 $\therefore$
iabbrev IMPL $\implies$

" Economics-specific abbreviations{{{2
iabbrev gnss goods and services
iabbrev gns good and service
iabbrev eqb equilibrium
iabbrev govt government
" }}}2
" }}}
" ============================================================================
" KEYBINDS {{{ 
" ============================================================================
" Navigation {{{2
" Split/Window management
" Move windows
map <C-w><C-h> <C-w><S-h>
map <C-w><C-j> <C-w><S-j>
map <C-w><C-k> <C-w><S-k>
map <C-w><C-l> <C-w><S-l>

" Move BETWEEN windows
nnoremap <C-H> <C-W><C-H>
nnoremap <C-J> <C-W><C-J>
nnoremap <C-K> <C-W><C-K>
nnoremap <C-L> <C-W><C-L>

" Move by VISUAL lines
nnoremap  <buffer> <silent> k gk
vnoremap  <buffer> <silent> k gk
vnoremap  <buffer> <silent> k gk
nnoremap  <buffer> <silent> j gj
vnoremap  <buffer> <silent> j gj
nnoremap  <buffer> <silent> 0 g0
vnoremap  <buffer> <silent> 0 g0
nnoremap  <buffer> <silent> $ g$
vnoremap  <buffer> <silent> $ g$
" }}}2

" Search/replace {{{2
" Basically, put you between the brackets of s//g,
" type your search, then /, then your replacement
nmap S :%s///<LEFT>
vmap S :s///<LEFT>
nnoremap <silent> <leader>/ :nohlsearch<CR>

" Use '//' in visual mode to search for selection
vnoremap // y/<C-R>"<CR>
" }}}2

" Selecting and Pasting {{{2
" " Paste and move to end
" vnoremap <silent> y y`]
" vnoremap <silent> p p`]
" nnoremap <silent> p p`]

" Select what was pasted
noremap gV `[v`]

" Select ALL
nnoremap <leader>a ggVG

" Indent/De-dent visual selection
vnoremap < <gv
vnoremap > >gv
" }}}2

" Navigate quickfix/locationlist with keychords {{{2
" if empty(getloclist(0))
"     nnoremap <C-S-n> :cn<CR>
"     nnoremap <C-S-p> :cp<CR>
" else
"     nnoremap <C-S-n> :lnext<CR>
"     nnoremap <C-S-p> :lprev<CR>
" endif
" }}}2

" Buffer/File/Function/Outline navigation (CtrlP versus FZF) {{{2
if has('gui_running')
    nnoremap <leader>b  :CtrlPBuffer<Cr>
    nnoremap <leader>p  :CtrlP<Cr>
else
    nnoremap <leader>b :Buffers<Cr>
    nnoremap <C-p> :Files<Cr>
    nnoremap <leader>p :Files<Cr>
endif

" Funky (CtrlP for functions)
nnoremap <leader>fu :CtrlPFunky<Cr>
nnoremap <leader>fU :execute 'CtrlPFunky ' . expand('<cword>')<Cr>

" Keybinds to manipulate my vim config
nnoremap <leader>ev :e $MYVIMRC<Cr>G
nnoremap <leader>sv :so $MYVIMRC<Cr>

" Keybinds to go to specific files/dirs
nnoremap <leader>es :e $SRCME/
nnoremap <leader>ee :e $HOME/dev/etc/
" }}}2

" Miscellany {{{2
" Toggle hidden character visibility with
nmap <Leader>h :set list!<CR>
set listchars=tab:▸\ ,trail:·,extends:❯,precedes:❮,nbsp:×,eol:¬

" Toggle Vimtex Table of Contents
" nnoremap <leader>v :VimtexTocToggle<CR>

" Toggle tagbar
nnoremap <leader>t :TagbarToggle<CR>

" Swap colon and semicolon
nnoremap ; :
nnoremap : :

" Use spacebar for folds
nnoremap <space> za

" EX mode is a pain
map q: :q

" View and switch to buffer
nnoremap gb :ls<CR>:buffer<Space>

" Fold HTML tags
nnoremap <leader>ft Vatzf

" Format a paragraph
nnoremap <leader>q gqip

" Easily toggle distraction free - Goyo
nnoremap <F11> :Goyo<Cr>

command! CurPath let @+=expand("%")
" }}}2
" }}}
" ============================================================================
" Search/navigation --- FZF & rg/ag {{{ 
" ============================================================================
" --column: Show column number
" --line-number: Show line number
" --no-heading: Do not show file headings in results
" --fixed-strings: Search term as a literal string
" --ignore-case: Case insensitive search
" --no-ignore: Do not respect .gitignore, etc...
" --hidden: Search hidden files and folders
" --follow: Follow symlinks
" --glob: Additional conditions for search (in this case ignore everything in the .git/ folder)
" --color: Search color options

command! -bang -nargs=* Find call fzf#vim#grep('rg --column --line-number --no-heading --fixed-strings --ignore-case --no-ignore --hidden --follow --glob "!.git/*" --color "always" '.shellescape(<q-args>), 1, <bang>0)


" Use a better default searcher
" for both CtrlP and Grep
" ripgrep, if available, otherwise Ag
let g:ctrlp_use_caching = 0
if executable('rg')
  set grepprg=rg\ --vimgrep
  let g:ctrlp_user_command = 'rg %s --files --color=never --glob ""'
elseif executable('ag')
  " Use ag over grep
  set grepprg=ag\ --nogroup\ --nocolor
  let g:ctrlp_user_command = 'ag %s -l --nocolor -g ""'
else
    let g:ctrlp_use_caching = 1
endif

nnoremap <Leader>g :Find<SPACE>
nnoremap <leader>F :Find<SPACE>
" }}}
" ============================================================================
" LANGUAGES {{{ 
" ============================================================================
" Autocommand groups for filetypes/languages {{{2
augroup filetype_c
    autocmd!
    autocmd FileType c       set foldmethod=syntax
    autocmd FileType cpo     set foldmethod=syntax
    autocmd FileType arduino set foldmethod=syntax
augroup END

augroup filetype_py
    autocmd!
    autocmd FileType python  set foldmethod=indent
    autocmd FileType python  set tabstop=4
    autocmd FileType python  set softtabstop=4
augroup END

augroup filetype_json
    autocmd!
    autocmd FileType json    set tabstop=2
    autocmd FileType json    set softtabstop=2
    autocmd FileType json    set shiftwidth=2
augroup END

augroup filetype_go
    autocmd!
    autocmd FileType go      set nofen
    autocmd FileType go      set foldmethod=syntax
augroup END

augroup pandoc
    autocmd!
    autocmd Filetype markdown,pandoc setlocal wrap textwidth=80
    autocmd Filetype markdown,pandoc setlocal conceallevel=2
    autocmd Filetype markdown,pandoc hi Conceal cterm=NONE ctermbg=NONE
    autocmd Filetype markdown,pandoc hi Conceal guibg=NONE guifg=NONE
    autocmd BufEnter *.md setlocal foldexpr=MarkdownLevel()
    autocmd BufEnter *.md setlocal foldmethod=expr
augroup END

" Miscellany 
augroup filetype_miscellany
    autocmd!
    autocmd BufNewFile,BufReadPost *.tex set filetype=tex
    autocmd FileType make    set noexpandtab
    autocmd FileType rust    set foldmethod=syntax
    autocmd FileType vim     set foldmethod=marker
    autocmd BufNewFile,BufReadPost *.es6 set filetype=javascript
    autocmd BufEnter * hi vimOper cterm=NONE ctermbg=NONE
    autocmd BufEnter * hi vimOper guibg=NONE guifg=NONE
augroup END
" }}}2

" Let/settings for language-based packages {{{2
" Latex / Vimtex 
let g:vimtex_quickfix_ignore_all_warnings=1
let g:vimtex_latexmk_continuous=0
let g:vimtex_quickfix_mode=0
let g:tex_flavor = "latex"
let g:vimtex_indent_enabled=1
let g:vimtex_fold_enabled=1

" C++ 
let g:syntastic_cpp_compiler = 'clang++'
let g:syntastic_cpp_compiler_options = ' -std=c++11 -stdlib=libc++'

" Python 
let g:pymode_python = 'python3'

let g:syntastic_python_python_exec = '/usr/local/bin/python3'
let g:syntastic_python_checkers = ['flake8']

" Vim-slime - tmux & python
let g:slime_target = "tmux"
let g:slime_python_ipython = 1

" Settings --- 'let' commands 
let b:javascript_fold=1
let g:go_fmt_command = "goimports"

" Tables
let g:table_mode_corner="|"
let g:table_mode_corner_corner="|"
let g:table_mode_header_fillchar="-"

let g:tex_flavor='latex'

let g:UltiSnipsExpandTrigger="<tab>"
let g:UltiSnipsJumpForwardTrigger="<c-b>"
let g:UltiSnipsJumpForwardTrigger="<c-z>"
let g:UltiSnipsEditSplit="vertical"


let g:pandoc#spell#enabled=0
let g:pandoc#syntax#conceal#urls = 1
let g:pandoc#formatting#mode='s'
let g:pandoc#formatting#textwidth=0
let g:pandoc#formatting#equalprg = "pandoc -t markdown -s"
let g:pandoc#formatting#extra_equalprg = "--columns=80 --normalize --atx-headers"
let g:pandoc#syntax#conceal#blacklist = ['list', 'atx']
let g:vim_markdown_toc_autofit = 1
" }}}2
" }}}
" ============================================================================
" SHEBANG {{{ 
" ============================================================================
" Automatically add HashBang lines -----
function! Hashbang(portable, permission)
let shells = {
        \    'awk': "awk",
        \     'sh': "bash",
        \     'hs': "runhaskell",
        \     'jl': "julia",
        \    'lua': "lua",
        \    'mak': "make",
        \     'js': "node",
        \      'm': "octave",
        \     'pl': "perl",
        \    'php': "php",
        \     'py': "python",
        \      'r': "Rscript",
        \     'rb': "ruby",
        \  'scala': "scala",
        \    'tcl': "tclsh",
        \    ' tk': "wish"
        \    }

let extension = expand("%:e")

if has_key(shells,extension)
    let fileshell = shells[extension]

    if a:portable
        let line =  "#! /usr/bin/env " . fileshell
    else
        let line = "#! " . system("which " . fileshell)
    endif

    0put = line

    if a:permission
        :autocmd BufWritePost * :autocmd VimLeave * :!chmod u+x %
    endif

endif

endfunction

autocmd! BufNewFile *.* :call Hashbang(1,1)

" }}}
" ============================================================================
" STATUSBAR {{{ 
" ============================================================================
" Vim status bar
" %< Where to truncate
" %n buffer number
" %F Full path
" %m Modified flag: [+], [-]
" %r Readonly flag: [RO]
" %y Type:          [vim]
" fugitive#statusline()
" %= Separator
" %-14.(...)
" %l Line
" %c Column
" %V Virtual column
" %P Percentage
" %#HighlightGroup#
if 1
    set statusline=%<[%n]\ %F\ %m%r%y\ %{exists('g:loaded_fugitive')?fugitive#statusline():''}\ %=%-14.(%l,%c%V%)\ %P
    silent! if emoji#available()
      let s:ft_emoji = map({
        \ 'c':          'baby_chick',
        \ 'clojure':    'lollipop',
        \ 'coffee':     'coffee',
        \ 'cpp':        'chicken',
        \ 'css':        'art',
        \ 'eruby':      'ring',
        \ 'gitcommit':  'soon',
        \ 'haml':       'hammer',
        \ 'help':       'angel',
        \ 'html':       'herb',
        \ 'java':       'older_man',
        \ 'javascript': 'monkey',
        \ 'make':       'seedling',
        \ 'markdown':   'book',
        \ 'perl':       'camel',
        \ 'python':     'snake',
        \ 'ruby':       'gem',
        \ 'scala':      'barber',
        \ 'sh':         'shell',
        \ 'slim':       'dancer',
        \ 'text':       'books',
        \ 'vim':        'poop',
        \ 'vim-plug':   'electric_plug',
        \ 'yaml':       'yum',
        \ 'yaml.jinja': 'yum'
        \ }, 'emoji#for(v:val)')

        function! S_filetype()
        if empty(&filetype)
          return emoji#for('grey_question')
        else
          return get(s:ft_emoji, &filetype, '['.&filetype.']')
        endif
      endfunction

      function! S_modified()
        if &modified
          return emoji#for('kiss').' '
        elseif !&modifiable
          return emoji#for('construction').' '
        else
          return ''
        endif
      endfunction

      function! S_fugitive()
        if !exists('g:loaded_fugitive')
          return ''
        endif
        let head = fugitive#head()
        if empty(head)
          return ''
        else
          return head == 'master' ? emoji#for('crown') : emoji#for('dango').'='.head
        endif
      endfunction

      let s:braille = split('"⠉⠒⠤⣀', '\zs')
      function! Braille()
        let len = len(s:braille)
        let [cur, max] = [line('.'), line('$')]
        let pos  = min([len * (cur - 1) / max([1, max - 1]), len - 1])
        return s:braille[pos]
      endfunction

      hi def link User1 TablineFill
      let s:cherry = emoji#for('cherry_blossom')
      function! MyStatusLine()
        let mod = '%{S_modified()}'
        let ro  = "%{&readonly ? emoji#for('lock') . ' ' : ''}"
        let ft  = '%{S_filetype()}'
        let fug = ' %{S_fugitive()}'
        let sep = ' %= '
        let pos = ' %l,%c%V '
        let pct = ' %P '

        return s:cherry.' [%n] %F %<'.mod.ro.ft.fug.sep.pos.'%{Braille()}%*'.pct.s:cherry
      endfunction

      " Note that the "%!" expression is evaluated in the context of the
      " current window and buffer, while %{} items are evaluated in the
      " context of the window that the statusline belongs to.
      set statusline=%!MyStatusLine()
    endif
endif
" }}}
" ============================================================================
" SUPERTAB {{{ 
" ============================================================================
let g:SuperTabDefaultCompletionType = "context"
" }}}
" ============================================================================
" SYNTASTIC {{{ 
" ============================================================================
" set statusline+=%#warningmsg#
" set statusline+=%*

let g:syntastic_always_populate_loc_list = 1
let g:syntastic_auto_loc_list = 1
let g:syntastic_check_on_open = 1
let g:syntastic_check_on_wq = 0
" }}}
" ============================================================================
" GOYO -- Distraction free writing {{{ 
" ============================================================================
autocmd! User GoyoEnter Limelight
autocmd! User GoyoLeave Limelight!
let g:goyo_width=80
" }}}
" ============================================================================
" FUNCTIONS {{{ 
" ============================================================================
" Custom fold {{{2
function! ToggleFold()
    if &foldlevel < 10
        set foldlevel=99
    else
        set foldlevel=0
    endif
endfunction

function! CustomFoldText()
     "get first non-blank line
     let fs = v:foldstart
     while getline(fs) =~ '^\s*$' | let fs = nextnonblank(fs + 1)
     endwhile
     if fs > v:foldend
         let line = getline(v:foldstart)
     else
         let line = substitute(getline(fs), '\t', repeat(' ', &tabstop), 'g')
     endif

     let w = winwidth(0) - &foldcolumn - (&number ? 6 : 0)
     let foldSize = 1 + v:foldend - v:foldstart
     let foldSizeStr = " [" . foldSize . " lines] "
     let foldLevelStr = repeat("<", v:foldlevel)
     let lineCount = line("$")
     let expansionString = repeat(" ", w - strwidth(foldSizeStr.line.foldLevelStr))
     return line . expansionString . foldSizeStr . foldLevelStr
endfunction
set foldnestmax=99
set foldtext=CustomFoldText()
" }}}2

" Toggle line wrapping {{{2
function! ToggleWrap()
    let wr=&wrap
    if wr
        set nowrap
    else
        set wrap
    endif
endfunction
" }}}2

" Copy filename of current file {{{2
function! CopyFilename()
    let @+=expand("%")
endfunction
" }}}2

" Open snippets for this filetype {{{2
function! OpenScopesSnippets()
    let ft = &filetype
    let dr = expand('~/.vim/snippets/')
    let fn = dr . ft . '.snippets'
    execute "e " . fn
endfunction
" }}}2

" Show the color syntax scope under point {{{2
function! s:GetScope()
    let s:vHi = synIDattr(synID(line("."),col("."),1),"name")
    let s:vTrans = synIDattr(synID(line("."),col("."),0),"name")
    let s:vLo = synIDattr(synIDtrans(synID(line("."),col("."),1)),"name")
    echo "hi<" . s:vHi . "> trans<" . s:vTrans . "> lo<" . s:vLo . ">"
endfunction
command! CurrentScope call s:GetScope()
" }}}2

" Markdown level, for folding {{{2
" Function for markdown folding 
function! MarkdownLevel()
    let h = matchstr(getline(v:lnum), '^#\+')
    if empty(h)
        return "="
    endif
    return ">" . len(h)
endfunction
" }}}2

" Functions for running pandoc on markdown files {{{2
" Generate a MD preview for the current file
function! MDPreview()
    silent !clear
    let frm = '--from markdown_github+yaml_metadata_block+raw_html'
    let cfg = '--toc --toc-depth=2 --mathjax -s --self-contained'
    let style = '-c ~/.dotfiles/github-markdown.css'
    let out = '-o ~/.mdpreview.html'
    let str = '!pandoc %' . ' ' . frm . ' ' . cfg . ' ' . style . ' ' . out
    " echo str
    execute str
endfunction
command! MDPreview call MDPreview()

" Tidy up the current markdown file 
function! s:MDToFormat()
    let md = 'markdown_github-hard_line_breaks'
    let meta = 'yaml_metadata_block'
    let math = 'tex_math_dollars'
    let blocks = 'line_blocks'
    let out = '--to=' . md . '+' . meta . '+' . math . '+' . blocks
    return out
endfunction

function! s:MDFormatExtra()
     return '--atx-headers --normalize --standalone'
endfunction

function! MDTidy()
    silent !clear
    let to = s:MDToFormat()
    let extra = s:MDFormatExtra() . ' --wrap=None'
    let out = '-o %'
    let mdtidy_command = 'pandoc % ' . to . ' ' . extra . ' ' . out
    execute "!" . mdtidy_command
endfunction

function! MDTidyWrap()
    silent !clear
    let to = s:MDToFormat()
    let extra = s:MDFormatExtra() . ' --columns=80'
    let out = '-o %'
    let mdtidy_command = 'pandoc % ' . to . ' ' . extra . ' ' . out
    execute "!" . mdtidy_command
endfunction
command! MDTidy call MDTidyWrap()

" Convert current markdown file to PDF 
function! MDToPDF()
    silent !clear
    let outfn=expand('%:r') . '.pdf'
    let cmd = 'pandoc % -o ' . outfn
    execute "!" . cmd
endfunction
command! MDToPDF call MDToPDF()
" }}}2

" Insert date/timestamp at point {{{2
function! InsertDateAtPoint()
    read!date "+\%Y-\%m-\%d"
    normal kJ
endfunction

function! InsertNamedDateAtPoint()
    read!date "+\%Y-\%m-\%d - \%a"
    normal kJ
endfunction

function! InsertTimestampAtPoint()
    read!date "+\%Y-\%m-\%d \%H:\%M:\%S"
    normal kJ
endfunction

command! Today call InsertDateAtPoint()
command! TodayNamed call InsertNamedDateAtPoint()
command! TimeNow call InsertTimestampAtPoint()
" }}}2

" Toggle theme between light and dark {{{2
function! ToggleTheme(mode)
    if a:mode == 'DARK'
        execute 'colorscheme ' g:cd_light_theme
        set bg=light
        let g:cd_theme_mode='LIGHT'
    else
        execute 'colorscheme ' g:cd_dark_theme
        set bg=dark
        let g:cd_theme_mode='DARK'
    endif
endfunction

command! ToggleTheme call ToggleTheme(cd_theme_mode)
command! DayTheme call ToggleTheme('DARK')
command! NightTheme call ToggleTheme('LIGHT')
" }}}2

" Schedule words, like Emacs' Org-Mode {{{2
let g:cd_schedule_words = [ 'TODO' , 'WIP' , 'DONE', 'CANCELLED' ]
function! RotateWord()
    let N = len(g:cd_schedule_words)
    let cur = substitute(expand('<cWORD>'), '\**', '', 'g')
    let idx = index(g:cd_schedule_words, cur)
    if idx >= 0
        let next = g:cd_schedule_words[(idx+1) % N]
        let cmd = "ciW**" . next . "**"
        execute "normal " . cmd
    endif
endfunction

function! ScheduleDone()
    let cur = substitute(expand('<cWORD>'), '\**', '', 'g')
    let idx = index(g:cd_schedule_words, cur)
    if idx >= 0
        let cmd = "ciW**DONE**"
        execute "normal " . cmd
    endif
endfunction

command! RotateScheduleWord call RotateWord()
command! ScheduleDone call ScheduleDone()
" }}}2

" Bindings for functions {{{2
noremap zt :call ToggleFold()<CR>
nmap nw :call ToggleWrap()<CR>
nnoremap fmt :normal "ggVG="<Cr>
nnoremap <leader>os mZ:call OpenScopesSnippets()<Cr>
map <F10> :CurrentScope<Cr>
nnoremap <leader>r  :RotateScheduleWord<Cr>
nnoremap <leader>d  :ScheduleDone<Cr>
" }}}2
" }}}
" ============================================================================
" ----- EXPERIMENTAL ----- {{{ 
" ============================================================================
" enable dictionary, and use it in autocomplete
set dictionary+=/usr/share/dict/words
set complete+=k

command! Wd write|bdelete

set autoread
set updatetime=1000

augroup autoSaveAndRead
    autocmd!
    autocmd TextChanged,InsertLeave,FocusLost * silent! wall
    autocmd CursorHold * silent! checktime
augroup END


iabbrev invq ¿
let g:snips_author='Chris Davison'
let g:snips_email='c.jr.davison@gmail.com'
let g:snips_github='ChrisDavison'
let g:netrw_list_hide = "*.swp,*.swo,*.aux"


function! ToggleLinum()
    set relativenumber!
    set number!
endfunction

command! ToggleLinum call ToggleLinum()
"}}}
"============================================================================
