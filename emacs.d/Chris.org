#+TITLE: My Emacs configuration

* export config :noexport:
#+AUTHOR: Chris Davison
#+EMAIL: c.jr.davison@gmail.com
#+OPTIONS: toc:nil
#+PROPERTY: header-args  :results silent
#+REVEAL_ROOT: http://cdn.jsdelivr.net/reveal.js/2.5.0/
#+REVEAL_THEME: moon 
# solarized

* about this file
Inspired by [[http://pages.sachachua.com/.emacs.d/Sacha.html#unnumbered-3][Sacha Chua's Config]], I decided to move from a multi-file approach, to use org mode's power to really easily manage the complexity.

I can selectively export functionality by choosing to *tangle* the source code or not.

By adding the following into your emacs =init.el=, you can then move all your config into a documented org file.

#+BEGIN_SRC emacs-lisp  :tangle no
  ;; This sets up the load path so that we can override it
  (package-initialize nil)

  ;; Load the rest of the packages
  (package-initialize t)
  (setq package-enable-at-startup nil)

  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))

  ;; Try the 'use package' macro, from jwiegley on github
  (unless (package-installed-p 'use-package)
    (package-refresh-contents)
    (package-install 'use-package))

  ;; From here on, the org config will use the use-package macro for installing and configuring packages
  (require 'use-package)

  ;; Finally, load my literate config
  (org-babel-load-file "~/.emacs.d/Chris.org")
#+end_src

* initialisation
** consts
Basically give a useful const to check if running OSX.  This may be useful for your config, to override platform-specific behaviour (or perhaps implement some more specificity).
#+BEGIN_SRC emacs-lisp
  (defconst *spell-check-support-enabled* nil)
  (defconst *is-a-mac* (eq system-type 'darwin))
#+END_SRC

** package management
Refresh the package list, to get newest versions.  Can cause a slight delay when opening emacs.
Add org and use melpa for most packages.

#+BEGIN_SRC emacs-lisp
  ;; Tangle to update packages, or call yourself
  (package-refresh-contents)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))
  (add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
#+END_SRC

** eval after load
#+BEGIN_SRC emacs-lisp
(if (fboundp 'with-eval-after-load)
  (defalias 'after-load 'with-eval-after-load)
  (defmacro after-load (feature &rest body)
    "After FEATURE is loaded, evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,feature
                      '(progn ,@body))))
#+END_SRC

** file deletion utilities
Delete the current file.  Basically a big of sugar around =delete-file= to take the current buffer.
#+BEGIN_SRC emacs-lisp
(defun delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (or (buffer-file-name) (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))
#+END_SRC

** easier add-to-list
   Give regex patterns to add-auto-mode, so you don't need to call add-to-list multiple times (it'll do it for you).
   #+BEGIN_SRC emacs-lisp
(defun add-auto-mode (mode &rest patterns)
  "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
  (dolist (pattern patterns)
    (add-to-list 'auto-mode-alist (cons pattern mode))))
   #+END_SRC
   
** and then initialize...
#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
(package-initialize)

(use-package fullframe
  :ensure t
  :config (fullframe list-packages quit-window))
#+END_SRC

** common lisp libs
Useful to have access to power of common lisp within emacs.
#+BEGIN_SRC emacs-lisp
(use-package cl-lib
  :ensure t
  :config (require 'cl-lib))
#+END_SRC

** diminish minor modes
#+BEGIN_SRC emacs-lisp
(use-package diminish :ensure t)
#+END_SRC

* appearance
** font stuff
   #+BEGIN_SRC emacs-lisp
(when (member "Input Mono" (font-family-list))
  (set-default-font "Input Mono 14"))
  ;;(set-face-attribute 'default nil :font "Input Mono" :height 120))
(setq line-spacing 0.2)
   #+END_SRC
   
** colour theme 
   I always end up going back to solarized, but have been using 'github' within VIM, so should look into alternatives.  Also added functions to quickly jump between light and dark themes.
   #+BEGIN_SRC emacs-lisp
     (use-package solarized-theme :ensure t)
     (use-package molokai-theme :ensure t)
     (use-package seoul256-theme :ensure t) ; enable once melpa updates today

     ;;(load-theme seoul256 t)
   #+END_SRC
   
** *maybe* suspend frame
   This is useful if running a mac, so that C-z wont hide it.  Considered 'appearance' as I want to see windows.
   #+BEGIN_SRC emacs-lisp
(defun maybe-suspend-frame ()
  (interactive)
  (unless (and *is-a-mac* window-system)
    (suspend-frame)))

(global-set-key (kbd "C-z") 'maybe-suspend-frame)
   #+END_SRC
   
** suppress gui features
   #+BEGIN_SRC emacs-lisp
  (setq use-file-dialog nil)
  (setq use-dialog-box nil)
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-echo-area-message t)
   #+END_SRC
   
   Hide tool bar,  scroll bar and borders
   #+BEGIN_SRC emacs-lisp
(when (fboundp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (fboundp 'set-scroll-bar-mode)
  (set-scroll-bar-mode nil))

(let ((no-border '(internal-border-width . 0)))
  (add-to-list 'default-frame-alist no-border)
  (add-to-list 'initial-frame-alist no-border))
   #+END_SRC
   
** highlight current line and no blinking cursor
   #+BEGIN_SRC emacs-lisp
     (global-hl-line-mode 1)
     (blink-cursor-mode 0)
     (setq linum-format "%d ")
   #+END_SRC
   
** alias for yes-or-no
   This is again a quality of life thing, to allow you to hit yes or no by using y or n.
   #+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
   #+END_SRC
   
** faster keystroke echoing
   #+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
   #+END_SRC
   
** tabs to spaces, and tab-related things
   #+BEGIN_SRC emacs-lisp
(setq tab-stop-list (number-sequence 2 200 2))
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
   #+END_SRC
   
** show line and column number in status bar
   #+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
   #+END_SRC
   
** stop scrolling jumping multiple lines
   #+BEGIN_SRC emacs-lisp
  (setq scroll-step           1
        scroll-conservatively 10000)
   #+END_SRC
   
** scratch buffer - initial message
   #+BEGIN_SRC emacs-lisp
  (setq-default initial-scratch-message ";; Scratch pad\n\n")
   #+END_SRC
   
** font-locking
   Replace any occurrence of 'lambda' with the actual symbol.
   #+BEGIN_SRC emacs-lisp 
  (global-prettify-symbols-mode +1)
   #+END_SRC
   
** smart mode line
#+BEGIN_SRC emacs-lisp
(sml/setup)
#+END_SRC
* vim
Being a VIM user...Emacs' keybindings are quite nasty.  As such, I try to make this editing experience as close to the VIM experience as possible, while allowing for the nicety of Emacs.  Key-chord is pretty nice to keep my key presses down.

#+BEGIN_SRC emacs-lisp
  (use-package evil
    :ensure t
    :config (evil-mode 1))

  (use-package evil-surround
    :ensure t
    :config (global-evil-surround-mode))


  (use-package evil-leader 
    :ensure t 
    :config (global-evil-leader-mode))

  (use-package key-chord
    :ensure t
    :config (key-chord-mode 1))

  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)

  (define-key evil-normal-state-map (kbd ";") 'evil-ex)

  (key-chord-define-global "jk" 'evil-normal-state)
  (key-chord-define-global "gc" 'comment-or-uncomment-region)

  ;; Some of these functions are only pulled in later
  ;; But VIM is added early incase customisation breaks.
  (evil-leader/set-key
    "w" 'save-buffer
    "f" 'helm-find-files
    "h" 'helm-mini
    "o" 'helm-occur
    "s" 'helm-swoop
    "i" 'helm-imenu
    "j" 'jump-to-register
    "k" 'kill-buffer)

#+END_SRC

* history, backups, session and undo
Disk space is plentiful.  Keep backups and history.  Also, move the backups to the appropriate dir, so the backup files =.*~= don't clutter.

#+begin_src emacs-lisp
  (setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
  (setq delete-old-versions -1)
  (setq version-control t)
  (setq vc-make-backup-files t)
  (setq auto-save-file-name-transforms 
        '((".*" "~/.emacs.d/auto-save-list/" t)))

  (setq savehist-file "~/.emacs.d/savehist")
  (savehist-mode 1)
  (setq history-length t)
  (setq history-delete-duplicates t)
  (setq savehist-save-minibuffer-history 1)
  (setq savehist-additional-variables
        '(kill-ring
          search-ring
          regexp-search-ring))

  ;; Counting 'recent files' as part of history
  (use-package recentf
    :ensure t
    :config (recentf-mode))
  (setq recentf-max-saved-items 200)
  (setq recentf-max-menu-items 15)
  (recentf-mode)

  ;; Always save the desktop, the current workspace config
  (setq desktop-path (list user-emacs-directory)
        desktop-auto-save-timeout 600)
  (desktop-save-mode 1)

  ;; Reload when file changed on disk
  (global-auto-revert-mode t)
#+end_src

** recent files

#+begin_src emacs-lisp
(require 'recentf)
(setq recentf-max-saved-items 200
      recentf-max-menu-items 15)
(recentf-mode)
#+end_src

** undo tree  - visualize your undos and branches

People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.

This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+begin_src emacs-lisp
  (use-package undo-tree
    :diminish undo-tree-mode
    :config 
    (global-undo-tree-mode)
    (setq undo-tree-visualizer-timestamps nil)
    (setq undo-tree-visualizer-diff t))
#+end_src

* text editing
** parentheses
Show matching parens.  Use paredit to make shifting parens easier, and colourise parens using rainbow delimeters to increase visual clarity.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package paredit
    :ensure t
    :init (show-paren-mode t))

  (use-package rainbow-delimiters
    :ensure t
    :config (add-hook 'prog-mode-hook 'rainbow-delimiters-mode))
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (show-paren-mode 1)
  (use-package smartparens
    :ensure t
    :config 
    (require 'smartparens-config)
    (add-hook 'prog-mode-hook #'smartparens-strict-mode)
    (key-chord-define-global ">)" 'sp-forward-slurp-sexp)
    (key-chord-define-global ">(" 'sp-forward-barf-sexp)
    (key-chord-define-global "<)" 'sp-backward-slurp-sexp)
    (key-chord-define-global "<(" 'sp-backward-barf-sexp))

  (use-package evil-smartparens
    :ensure t
    :diminish evil-smartparens-mode
    :config
    (add-hook 'smartparens-mode #'evil-smartparens)
    (add-hook 'smartparens-strict-mode #'evil-smartparens))
#+END_SRC

** clean up spaces
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-SPC") 'cycle-spacing)
#+END_SRC
** expand region
#+BEGIN_SRC emacs-lisp
(use-package expand-region
:ensure t
:bind ("C-=" . er/expand-region))
#+END_SRC
** word wrapping and truncation
Couldn't get this working directly...so functionalise it
#+BEGIN_SRC emacs-lisp
  (defun trunc-wrap()
    "Turn on truncation and word wrapping"
    (interactive)
    (if truncate-lines 
        (progn
          (setq truncate-lines nil)
          (setq word-wrap t)
          (message "Truncation and word wrap enabled"))
      (progn 
        (setq truncate-lines t)
        (setq word-wrap nil)
        (message "Truncation and word wrap disabled"))))

  (key-chord-define-global "tw" 'trunc-wrap)
  (setq truncate-lines t)
  (setq word-wrap t)
#+END_SRC

** aggressive indentation
#+BEGIN_SRC emacs-lisp
  (use-package aggressive-indent
    :ensure t
    :config (global-aggressive-indent-mode))
#+END_SRC

** indent after newline
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "RET") 'newline-and-indent)
  (defun sanityinc/newline-at-end-of-line ()
    "Move to end of line, enter a newline, and reindent."
    (interactive)
    (move-end-of-line 1)
    (newline-and-indent))
#+END_SRC

* search && navigation
From http://www.masteringemacs.org/articles/2011/03/25/working-multiple-files-dired/

Generally improve dired appearance
#+begin_src emacs-lisp 

  (use-package dired+
    :config (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld")))

  (use-package find-dired
    :ensure dired+
    :config
    (setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
    (setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$") 
    (diredp-toggle-find-file-reuse-dir 1)) 
#+END_SRC

Hide files beginning with .[not a dot]
#+BEGIN_SRC emacs-lisp
  (setq dired-omit-mode t)
  (setq dired-omit-files "^\\.?#\\|^\\.$\\|^\\.\\.$\\|^\\.\\|^__.*$")
#+END_SRC

Show current and total matches while searching
#+BEGIN_SRC emacs-lisp
  ;; Show current and total matches while searching
  (use-package anzu
    :ensure t
    :diminish anzu-mode
    :bind (([remap query-replace-regexp] . anzu-query-replace-regexp)
           ([remap query-replace] . anzu-query-replace))
    :config (global-anzu-mode t))

  ;; DEL during isearch should edit the search string, not jump back to the previous result
  (define-key isearch-mode-map [remap isearch-delete-char] 'isearch-del-char)

  ;; ace-mode is fantastic.  It's a hybrid of ace-jump and isearch
  ;; Hybrid of isearch and ace-jump.  Type a single character in search and words beginning with that will highlight.  Press the highlighted letter to jump to that occurence
  (use-package ace-isearch
    :ensure t
    :config (global-ace-isearch-mode 1))

  ;; smartscan (Vim *)
  ;; From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el
  ;; This basically allows you to do something similar to VIM *...i.e. it'll jump forward or backward to the next occurence of the symbol under the cursor.
  ;; Bound to =M-n= and =M-b= by default, I think.
  (use-package smartscan
    :ensure t
    :config (global-smartscan-mode t))
#+end_src

Prompt with a hud when switching to a window in a multi-pane display
#+BEGIN_SRC emacs-lisp
;; Prompt with a hud when switching windows, if more than 2 windows
  (use-package switch-window
    :ensure t
    :config (setq switch-window-shortcut-style 'alphabet)
    :bind ("C-x o" . switch-window))
#+END_SRC

Interactively modify the buffer list
#+BEGIN_SRC emacs-lisp
;; Interactively modify buffer list
  (use-package fullframe :ensure t)
  (after-load 'buffer
    (fullframe ibuffer ibuffer-quit))

  (use-package ibuffer-vc :ensure t)

  (defun ibuffer-set-up-preferred-filters ()
    (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'filename/process)
      (ibuffer-do-sort-by-filename/process)))

  (add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters)

  (after-load 'ibuffer
    ;; Use human readable Size column instead of original one
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size))))))


  ;; Explicitly require ibuffer-vc to get its column definitions, which
  ;; can't be autoloaded
  (after-load 'ibuffer
    (require 'ibuffer-vc))

  ;; Modify the default ibuffer-formats (toggle with `)
  (setq ibuffer-formats
        '((mark modified read-only vc-status-mini " "
                (name 18 18 :left :elide) " "
                (size-h 9 -1 :right) " "
                (mode 16 16 :left :elide) " "
                filename-and-process)
          (mark modified read-only vc-status-mini " "
                (name 18 18 :left :elide) " "
                (size-h 9 -1 :right) " "
                (mode 16 16 :left :elide) " "
                (vc-status 16 16 :left) " "
                filename-and-process)))

  (setq ibuffer-filter-group-name-face 'font-lock-doc-face)

  (global-set-key (kbd "C-x C-b") 'ibuffer)

#+END_SRC

Code folding
#+BEGIN_SRC emacs-lisp
(use-package fold-dwim :ensure t)
(use-package fold-dwim-org :ensure t)

(add-hook 'prog-mode-hook #'hs-minor-mode)
(add-hook 'prog-mode-hook #'fold-dwim-org/minor-mode)
#+END_SRC

* utility
** help - guide-key

It's hard to remember keyboard shortcuts. The =guide-key= package pops up help after a short delay.

#+begin_src emacs-lisp
  (use-package guide-key
    :diminish guide-key-mode
    :ensure t
    :init (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
    :config (guide-key-mode 1))
#+end_src

** utf-8

From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

** mac osx
Mac needs a little bit of hand holding...
#+BEGIN_SRC emacs-lisp
  (when *is-a-mac*
    (setq mac-command-modifier 'meta)
    (setq mac-option-modifier 'none)
    (setq default-input-method "MacOSX")
    (use-package exec-path-from-shell :ensure t)

    ;;Make the mouse wheel/trackpad less jerky
    (setq mouse-wheel-scroll-amount '(1
                                      ((shift) . 5)
                                      ((control))))
    (dolist (multiple '("" "double-" "triple-"))
      (dolist (direction '("right" "left"))
        (global-set-key (kbd (concat "<" multiple "wheel-" direction ">")) 'ignore)))

    ;;And give emacs some of the expected OS X keybinds
    (global-set-key (kbd "M-`") 'ns-next-frame)
    (global-set-key (kbd "M-h") 'ns-do-hide-emacs)
    (global-set-key (kbd "M-˙") 'ns-do-hide-others)
    (after-load 'nxml-mode
      (define-key nxml-mode-map (kbd "M-h") nil))
    (global-set-key (kbd "M-ˍ") 'ns-do-hide-others) ;; what describe-key reports for cmd-option-h
    (global-set-key (kbd "M-<up>") 'toggle-frame-fullscreen) ;;Bind Meta-<UP> to fullscreen toggling
    (global-set-key (kbd "<f10>") 'toggle-frame-fullscreen) ;;Bind Meta-<UP> to fullscreen toggling
)
#+END_SRC

* prog languages
** quick configs
  Re-writing this to only use use-package, as it clears it up fairly well
#+BEGIN_SRC emacs-lisp
  (use-package flycheck :ensure t)

  ;; not sure if add-auto-mode works like the setq...so leaving for now
  (use-package markdown-mode
    :ensure t
    :config (add-auto-mode 'markdown-mode "\\.\\(md\\|markdown\\)\\'"))

  (use-package csv-mode
    :ensure csv-nav
    :mode ("\\.[Cc][Ss][Vv]\\'" . csv-mode)
    :config (setq csv-separators '("," ";" "|" " ")))

  ;; Emmet is fantastic for quickly outlining HTML
  (use-package emmet-mode
    :ensure t
    :config 
    (add-hook 'sgml-mode-hook 'emmet-mode)
    (add-hook 'css-mode-hook 'emmet-mode)
    (setq emmet-move-cursor-between-quotes t))

  (use-package haml-mode :ensure t)
  (use-package sass-mode :ensure t)
  (use-package scss-mode
    :ensure t
    :config (setq-default scss-compile-at-save t))

  (use-package coffee-mode :ensure t)

  ;; Colourize CSS literals
  (use-package rainbow-mode
    :ensure t
    :config 
    (add-hook 'css-mode-hook 'rainbow-mode)
    (add-hook 'html-mode-hook 'rainbow-mode)
    (add-hook 'sass-mode-hook 'rainbow-mode))

  ;; Racket
  (use-package racket-mode
    :ensure t
    :config 
    (add-hook 'racket-mode-hook 'paredit-mode)
    (setq racket-racket-program "/usr/local/bin/racket")
    (setq racket-raco-program "/usr/local/bin/raco") 
    (setq racket-program "/usr/local/bin/racket")
    (setq raco-program "/usr/local/bin/raco"))

  ;; Go
  (use-package go-mode
    :config (add-hook 'before-save-hook 'gofmt-before-save))

  ;; Rust
  (use-package rust-mode)
  (use-package flymake-rust)
  (use-package flycheck-rust)

  ;; Python
  (use-package virtualenvwrapper
    :ensure t
    :config
    (venv-initialize-interactive-shells) 
    (venv-initialize-eshell)
    (setq venv-location "/Users/davison/Envs/")
    (add-hook 'python-mode-hook (lambda () (venv-workon "numeric"))))

  (use-package ob-ipython
    :ensure t)

  (use-package ein :ensure t)

  (use-package clojure-mode :ensure t)
  (use-package clojure-mode-extra-font-locking :ensure t)
  (use-package cider 
    :ensure t
    :config
    (add-hook 'cider-mode-hook 'cider-turn-on-eldoc-mode)
    (setq cider-repl-pop-to-buffer-on-connect t)
    (setq cider-show-error-buffer t)
    (setq cider-repl-result-prefix ";; => ")
    (setq cider-interactive-eval-result-prefix ";; => ")
    (setq cider-repl-use-clojure-font-lock t)
    (setq cider-auto-select-error-buffer t)
    (setq cider-lein-command "/usr/local/bin/lein")
    (add-hook 'cider-repl-mode-hook 'smartparens-mode)
    (cider-repl-set-ns "user"))

  ;;(diminish 'auto-complete-mode)
  (diminish 'hs-minor-mode)
  (diminish 'smartparens-mode)
  ;;(diminish 'smartparens-strict-mode)
   #+END_SRC
** lisp
   Paredit was included earlier as it's just generally useful.
   
   Give a default message when opening a scratch (elisp) buffer.
   #+BEGIN_SRC emacs-lisp
  (setq-default initial-scratch-message
                (concat ";; Happy hacking, " (or user-login-name "") "!\n\n"))
   #+END_SRC
   
   Automatically byte-compile
   #+begin_src emacs-lisp
     (use-package auto-compile
       :config 
       (auto-compile-on-save-mode 1)
       (auto-compile-on-load-mode 1)
       (setq load-prefer-newer t))

     #+end_src
   
   Hook some useful settings into lisp modes
   #+begin_src emacs-lisp
     (defun davison/useful-lisp ()
       (rainbow-delimiters-mode t)
       (enable-paredit-mode)
       (when (fboundp 'aggressive-indent-mode)
         (aggressive-indent-mode)))

     (add-hook 'lisp-mode 'davison/useful-lisp)
     (add-hook 'emacs-lisp-mode 'davison/useful-lisp)
   #+end_src
   
** latex
#+BEGIN_SRC emacs-lisp :tangle no
;; General config
  (require-package 'auctex)
  (setq TeX-auto-save t)
  (setq TeX-parse-self t)
  (setq TeX-save-query nil)

  (setq ispell-program-name "aspell") ; could be ispell as well, depending on your preferences
  (setq ispell-dictionary "english") ; this can obviously be set to any language your spell-checking program supports

  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-buffer)

  (defun turn-on-outline-minor-mode ()
  (outline-minor-mode 1))

  (add-hook 'LaTeX-mode-hook 'turn-on-outline-minor-mode)
  (add-hook 'latex-mode-hook 'turn-on-outline-minor-mode)
  (setq outline-minor-mode-prefix "\C-c \C-o") ; Or something else
#+END_SRC

#+BEGIN_SRC :tangle no
;; Manage citations
  (require 'tex-site)
  (autoload 'reftex-mode "reftex" "RefTeX Minor Mode" t)
  (autoload 'turn-on-reftex "reftex" "RefTeX Minor Mode" nil)
  (autoload 'reftex-citation "reftex-cite" "Make citation" nil)
  (autoload 'reftex-index-phrase-mode "reftex-index" "Phrase Mode" t)
  (add-hook 'latex-mode-hook 'turn-on-reftex)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)

  (setq LaTeX-eqnarray-label "eq"
        LaTeX-equation-label "eq"
        LaTeX-figure-label "fig"
        LaTeX-table-label "tab"
        LaTeX-myChapter-label "chap"
        TeX-auto-save t
        TeX-newline-function 'reindent-then-newline-and-indent
        TeX-parse-self t
        TeX-style-path
        '("style/" "auto/"
          "/usr/share/emacs21/site-lisp/auctex/style/"
          "/var/lib/auctex/emacs21/"
          "/usr/local/share/emacs/site-lisp/auctex/style/")
        LaTeX-section-hook
        '(LaTeX-section-heading
          LaTeX-section-title
          LaTeX-section-toc
          LaTeX-section-section
          LaTeX-section-label))
#+END_SRC

* ido
Could Helm be a better all-round replacement for Ido?  Don't include IDO for now.
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package ido
    :ensure t
    :config 
    (ido-mode t)
    (ido-everywhere t)
    (setq ido-enable-flex-matching t)
    (setq ido-use-filename-at-point nil)
    (setq ido-auto-merge-work-directories-length 0)
    (setq ido-use-virtual-buffers t))

  (use-package ido-menu
    :ensure ido
    :config 
    (setq ido-default-buffer-method 'selected-window)
    (ido-mode -1))

  (use-package ido-ubiquitous
    :ensure t
    :config (ido-ubiquitous-mode t))

  ;; Use smex to handle M-x
  (use-package smex
    :config
    (setq smex-save-file (expand-file-name ".smex-items" user-emacs-directory))
    (global-set-key [remap execute-extended-command] 'smex))
#+END_SRC

* org-mode
** taking notes
Set up org for taking notes, using Dropbox/docs as my main folder.  Also, set up some nice config for org todo and agenda stuff.

=org-refile= lets you organize notes by typing in the headline to file them under.
#+BEGIN_SRC emacs-lisp
  (use-package org
    :ensure t
    :bind (("<f1>" . org-capture)
           ("<f2>" . org-agenda)
           ("<f3>" . org-agenda-list)
           ("<f4>" . org-timeline))
    :config
    (setq org-directory "~/Dropbox/docs")
    (setq org-default-notes-file "~/Dropbox/docs/notes.org")
    (setq org-src-window-setup 'current-window) 
    (setq org-src-fontify-natively t)
    (setq org-agenda-files
          (delq nil (mapcar (lambda (x) (and (file-exists-p x) x))
                            '("~/Dropbox/docs/"))))
    (setq org-todo-keywords 
          '((sequence "-TODO-(t)" "-WIP(w)-"
                      "|"
                      "-DONE(d)-" "-CANCELLED-(c)")))
    (setq org-startup-indented t)
    (add-hook 'org-mode-hook '(diminish 'org-indent-mode))
    
    ;; Settings for refiling
    (setq org-reverse-note-order t)
    (setq org-refile-use-outline-path nil)
    (setq org-refile-allow-creating-parent-nodes 'confirm)
    (setq org-refile-use-cache nil)
    (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
    (setq org-blank-before-new-entry nil))

  (use-package ox-reveal :ensure t)
  (use-package htmlize :ensure t)
  (use-package org-bullets 
    :disabled t
    :ensure t
    :config (org-bullets-mode 1))
 
  
#+END_SRC

This makes it easier to add links from outside.
#+begin_src emacs-lisp
(defun sacha/yank-more ()
  (interactive)
  (insert "[[")
  (yank)
  (insert "][more]]"))
(global-set-key (kbd "<f6>") 'sacha/yank-more)
#+end_src

#+BEGIN_SRC emacs-lisp :tangle no
Paste a link into an org file document, using the currently selected text as the description

Something like Sacha Chua's yank-more, but using the current region as 'more'

Below is /kind of/ along the right lines, but need to make it work with either the kill ring or the clipboard, as well as removing the current region.
#+BEGIN_SRC emacs-lisp
  (setq save-interprogram-paste-before-kill t)

  (defun cd/yank-with-selection-as-description (title)
    (interactive "MLink Title: \n")
    (insert "[[")
    (clipboard-yank)
    (insert "][")
    (insert title)
    insert "]]"
    (message "Yanked with Selection"))

  (global-set-key (kbd "<f7>") 'cd/yank-with-selection-as-description)
#+END_SRC

** capture - templates
   =org-capture= lets you create templates for jotting down info of various kinds.

#+BEGIN_SRC emacs-lisp
    (setq org-capture-templates
          '(("i" "ideas" entry
             (file+headline "~/Dropbox/docs/notes.org" "Ideas")
             "** %^{Idea} \n%?"
             :immediate-finish)

            ("q" "quotes" entry
             (file+headline "~/Dropbox/docs/notes.org" "Quotes")
             "** %^{WHO? WHERE?}\n%^{QUOTE}"
             :immediate-finish)

            ("t" "todo" entry
             (file+headline "~/Dropbox/docs/notes.org" "Tasks")
             "** TODO %^{Task}\n%^{WHEN?}t\n%^{DETAILS}"
             :immediate-finish)

            ("e" "engd" entry
             (file+headline "~/Dropbox/docs/notes.org" "EngD")
             "** %^{WHAT}\n%?"
             :immediate-finish)))
#+end_src

** keyboard shortcuts
#+begin_src emacs-lisp :tangle no
    (global-set-key (kbd "<f1>") 'org-capture)
    (global-set-key (kbd "<f2>") 'org-agenda)
    (global-set-key (kbd "<f3>") 'org-agenda-list)
    (global-set-key (kbd "<f4>") 'org-timeline)
#+end_src

** indent org babel src
In an Org-Babel block, run my/org-cleanup to fix indentation
#+BEGIN_SRC emacs-lisp
  (defun my/org-cleanup ()
    (interactive)
    (org-edit-special)
    (indent-buffer)
    (org-edit-src-exit))

  (defun indent-buffer ()
    (interactive)
    (indent-region (point-min) (point-max)))

  (global-set-key (kbd "C-x c") 'my/org-cleanup)
#+END_SRC

** checkboxes in headings
#+BEGIN_SRC emacs-lisp
  (defun wicked/org-update-checkbox-count (&optional all)
    "Update the checkbox statistics in the current section.
  This will find all statistic cookies like [57%] and [6/12] and update
  them with the current numbers.  With optional prefix argument ALL,
  do this for the whole buffer."
    (interactive "P")
    (save-excursion
      (let* ((buffer-invisibility-spec (org-inhibit-invisibility)) 
             (beg (condition-case nil
                      (progn (outline-back-to-heading) (point))
                    (error (point-min))))
             (end (move-marker
                   (make-marker)
                   (progn (or (outline-get-next-sibling) ;; (1)
                              (goto-char (point-max)))
                          (point))))   
             (re "\\(\\[[0-9]*%\\]\\)\\|\\(\\[[0-9]*/[0-9]*\\]\\)")
             (re-box
              "^[ \t]*\\(*+\\|[-+*]\\|[0-9]+[.)]\\) +\\(\\[[- X]\\]\\)")
             b1 e1 f1 c-on c-off lim (cstat 0))
        (when all
          (goto-char (point-min))
          (or (outline-get-next-sibling) (goto-char (point-max))) ;; (2)
          (setq beg (point) end (point-max)))
        (goto-char beg)
        (while (re-search-forward re end t)
          (setq cstat (1+ cstat)
                b1 (match-beginning 0)
                e1 (match-end 0)
                f1 (match-beginning 1)
                lim (cond
                     ((org-on-heading-p)
                      (or (outline-get-next-sibling) ;; (3)
                          (goto-char (point-max)))
                      (point))
                     ((org-at-item-p) (org-end-of-item) (point))
                     (t nil))
                c-on 0 c-off 0)
          (goto-char e1)
          (when lim
            (while (re-search-forward re-box lim t)
              (if (member (match-string 2) '("[ ]" "[-]"))
                  (setq c-off (1+ c-off))
                (setq c-on (1+ c-on))))
            (goto-char b1)
            (insert (if f1
                        (format "[%d%%]" (/ (* 100 c-on)
                                            (max 1 (+ c-on c-off))))
                      (format "[%d/%d]" c-on (+ c-on c-off))))
            (and (looking-at "\\[.*?\\]")
                 (replace-match ""))))
        (when (interactive-p)
          (message "Checkbox statistics updated %s (%d places)"
                   (if all "in entire file" "in current outline entry")
                   cstat)))))
  (defadvice org-update-checkbox-count (around wicked activate)
    "Fix the built-in checkbox count to understand headlines."
    (setq ad-return-value
          (wicked/org-update-checkbox-count (ad-get-arg 1))))
#+END_SRC
** babel
#+BEGIN_SRC emacs-lisp
  (setq org-babel-load-languages
        '((emacs-lisp . t)
          (R . t)
          (Python . t)))

  (setq org-confirm-babel-evaluate nil)

  (define-skeleton org-skeleton
    "Header info for a emacs-org file."
    "-----\n"
    "#+TITLE: " (skeleton-read "Title: ") "\n"
    "#+AUTHOR: Chris Davison\n"
    "#+EMAIL: c.jr.davison@gmail.com\n"
    "#+OPTIONS: toc:2 num:nil html-postamble:nil\n"
    "#+PROPERTY: header-args :tangle " (skeleton-read "Tangle filename: ") "\n")
  ;;(global-set-key [C-S-f4] 'org-skeleton)
#+END_SRC
* Jump to commonly used files (set as registers)
Set files as registers and then comfortably jump to them 
#+BEGIN_SRC emacs-lisp
  ;;(global-set-key (kbd "C-x j") 'jump-to-register)
  (set-register ?c (cons 'file "~/.emacs.d/Chris.org"))
  (set-register ?u (cons 'file "~/Dropbox/docs/uni.org"))
  (set-register ?l (cons 'file "~/Dropbox/docs/lisps.org"))
  (set-register ?n (cons 'file "~/Dropbox/docs/notes.org"))
  (set-register ?r (cons 'file "~/Dropbox/docs/rust.org"))
  (set-register ?w (cons 'file "~/Dropbox/docs/wh40k.org"))
  (set-register ?d (cons 'file "~/Dropbox/docs/dw.org"))
  (set-register ?m (cons 'file "~/Dropbox/docs/numenera.org"))
  (set-register ?t (cons 'file "~/.tmp.org"))
#+END_SRC

* helm
general helm setup
#+BEGIN_SRC emacs-lisp
  (use-package helm
    :diminish helm-mode
    :ensure t
    :init (require 'helm-config)
    :config 
    (setq helm-candidate-number-limit 100
          helm-idle-delay 0.0
          helm-input-idle-delay 0.01
          helm-quick-update t
          helm-M-x-requires-pattern nil
          helm-ff-skip-boring-files t
          helm-recentf-fuzzy-match t
          helm-buffers-fuzzy-matching t
          helm-locate-fuzzy-match t
          helm-imenu-fuzzy-match t
          helm-M-x-fuzzy-match t
          helm-semantic-fuzzy-match t
          helm-apropos-fuzzy-match t
          helm-split-window-in-side-p t)
    (helm-mode 1)
    (helm-autoresize-mode 1))

  (use-package helm-descbinds :ensure t)
#+END_SRC

key bindings
#+BEGIN_SRC emacs-lisp 
  (global-set-key (kbd "C-c h") 'helm-mini)
  (global-set-key (kbd "C-c a") 'helm-apropos)
  (global-set-key (kbd "C-c o") 'helm-occur)
  (global-set-key (kbd "C-c s") 'helm-swoop)
  (global-set-key (kbd "C-c i") 'helm-imenu)
  (global-set-key (kbd "C-c b") 'helm-descbinds)
  (global-set-key (kbd "C-c r") 'helm-regexp)

  (global-set-key (kbd "C-x C-f") 'helm-find-files)

  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (global-set-key (kbd "M-x") 'helm-M-x)

#+END_SRC

#+BEGIN_SRC emacs-lisp
#+END_SRC

* helpers
#+BEGIN_SRC emacs-lisp
(use-package s :ensure t)
(use-package f :ensure t)
#+END_SRC
  
  
