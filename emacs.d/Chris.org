#+TITLE: Chris Davison's Emacs configuration
#+PROPERTY: header-args  :results silent

* about this file
<<babel-init>>

THIS NEEDS WORK:  In individual sections, split the code and add more explanation.

Inspired by Sacha Chua, I decided to move from a multi-file approach (which can be a bit of an issue when testing new things, to find the error in the file) to a single file approach, with the hope of tightening it all up and streamlining.

This can be saved directly in =~/.emacs.d= and loaded via =(org-babel-load-file "/path/to/file")=, and then use the benefit of sharing a single file, or a single section, as well as giving a single source by jumping to section headers.

To be precise, this is what's in the first part of my =~/.emacs.d/init.el= (what used to be the =~/.emacs= file):

#+begin_src emacs-lisp  :tangle no
    ;; This sets up the load path so that we can override it
    (package-initialize nil)

    ;; Load the rest of the packages
    (package-initialize t)
    (setq package-enable-at-startup nil)

    ;; Finally, load my literate config
    (org-babel-load-file "~/.emacs.d/Chris.org")
#+end_src

A tip is to generally always only copy individual sections, into a seperate buffer (i.e. =*scratch*= or another elisp buffer), evaluate that buffer (=M-x eval-buffer=) to see if you like the changes without actually merging it.

Useful: [[https://www.gnu.org/software/emacs/manual/html_mono/eintr.html][An Introduction to Programming in Emacs Lisp]]

You may see an unusual (non eLisp) construct in =(require-package 'something...)=, which is basically a function that will check if a package is installed, and if not install it.  Can't remember where this was from, but it's a useful construct for keeping things simple.

If you're viewing the Org inside emacs, you can open source blocks (ones beginning in begin_src) in a seperate buffer by moivng your point inside them and typing C-c ' (=ord-edit-special=).  This opens the block in an elisp buffer, so you can use =M-x eval-buffer= to load the changes.

* personal information
#+begin_src emacs-lisp
  (setq user-full-name "Chris Davison"
      user-mail-address "c.jr.davison@gmail.com")
#+end_src
  
* initialisation
** consts
Basically give a useful const to check if running OSX.  This may be useful for your config, to override platform-specific behaviour (or perhaps implement some more specificity).
#+BEGIN_SRC emacs-lisp
  (defconst *spell-check-support-enabled* nil)
  (defconst *is-a-mac* (eq system-type 'darwin))
#+END_SRC

** package management
Refresh the package list, to get newest versions.  Can cause a slight delay when opening emacs.
#+BEGIN_SRC emacs-lisp
  (package-refresh-contents)
#+END_SRC

On-demand package loading
#+BEGIN_SRC emacs-lisp
(defun require-package (package &optional min-version no-refresh)
  "Install given PACKAGE, optionally requiring MIN-VERSION.
If NO-REFRESH is non-nil, the available package lists will not be
re-downloaded in order to locate PACKAGE."
  (if (package-installed-p package min-version)
      t
    (if (or (assoc package package-archive-contents) no-refresh)
        (package-install package)
      (progn
        (package-refresh-contents)
        (require-package package min-version t)))))

(defun maybe-require-package (package &optional min-version no-refresh)
  "Try to install PACKAGE, and return non-nil if successful.
In the event of failure, return nil and print a warning message.
Optionally require MIN-VERSION.  If NO-REFRESH is non-nil, the
available package lists will not be re-downloaded in order to
locate PACKAGE."
  (condition-case err
      (require-package package min-version no-refresh)
    (error
     (message "Couldn't install package `%s': %S" package err)
     nil)))
#+END_SRC

** package sources
     Add org and gnu by default
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/"))

(when (< emacs-major-version 24)
  (add-to-list 'package-archives '("gnu" . "http://elpa.gnu.org/packages/")))
#+END_SRC

But use melpa for most packages
#+BEGIN_SRC emacs-lisp
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(add-to-list 'package-archives '("melpa-stable" . "http://stable.melpa.org/packages/"))
#+END_SRC

** eval after load
#+BEGIN_SRC emacs-lisp
(if (fboundp 'with-eval-after-load)
  (defalias 'after-load 'with-eval-after-load)
  (defmacro after-load (feature &rest body)
    "After FEATURE is loaded, evaluate BODY."
    (declare (indent defun))
    `(eval-after-load ,feature
                      '(progn ,@body))))
#+END_SRC

** file deletion utilities
Delete the current file.  Basically a big of sugar around =delete-file= to take the current buffer.
#+BEGIN_SRC emacs-lisp
(defun delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (or (buffer-file-name) (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))
#+END_SRC

** easier add-to-list
Give regex patterns to add-auto-mode, so you don't need to call add-to-list multiple times (it'll do it for you).
#+BEGIN_SRC emacs-lisp
(defun add-auto-mode (mode &rest patterns)
  "Add entries to `auto-mode-alist' to use `MODE' for all given file `PATTERNS'."
  (dolist (pattern patterns)
    (add-to-list 'auto-mode-alist (cons pattern mode))))
#+END_SRC

** and then initialize...
#+BEGIN_SRC emacs-lisp
(setq package-enable-at-startup nil)
(package-initialize)

(require-package 'fullframe)
(fullframe list-packages quit-window)
#+END_SRC

** common lisp libs
Useful to have access to power of common lisp within emacs.
#+BEGIN_SRC emacs-lisp
(require-package 'cl-lib)
(require 'cl-lib)
#+END_SRC

** diminish minor modes
#+BEGIN_SRC emacs-lisp
(require-package 'diminish)
#+END_SRC

* appearance
** font stuff
#+BEGIN_SRC emacs-lisp
(when (member "DejaVu Sans Mono" (font-family-list))
  (set-face-attribute 'default nil :font "DejaVu Sans Mono" :height 150))
(setq line-spacing 0.2)
#+END_SRC

** colour theme 
I always end up going back to solarized, but have been using 'github' within VIM, so should look into alternatives.
Also added functions to quickly jump between light and dark themes.
#+BEGIN_SRC emacs-lisp
  (require-package 'solarized-theme)
  (load-theme 'zenburn t)

  (defun light()
    "Activate a light color theme."
    (interactive)
    (load-theme 'solarized-light))

  (defun dark()
    "Activate a dark color theme."
    (interactive)
    (load-theme 'solarized-dark))
#+END_SRC
** *maybe* suspend frame
This is useful if running a mac, so that C-z wont hide it.  Considered 'appearance' as I want to see windows.
#+BEGIN_SRC emacs-lisp
(defun maybe-suspend-frame ()
  (interactive)
  (unless (and *is-a-mac* window-system)
    (suspend-frame)))

(global-set-key (kbd "C-z") 'maybe-suspend-frame)
#+END_SRC

** suppress gui features
#+BEGIN_SRC emacs-lisp
  (setq use-file-dialog nil)
  (setq use-dialog-box nil)
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-echo-area-message t)
#+END_SRC

Hide tool bar,  scroll bar and borders
#+BEGIN_SRC emacs-lisp
(when (fboundp 'tool-bar-mode)
  (tool-bar-mode -1))
(when (fboundp 'set-scroll-bar-mode)
  (set-scroll-bar-mode nil))

(let ((no-border '(internal-border-width . 0)))
  (add-to-list 'default-frame-alist no-border)
  (add-to-list 'initial-frame-alist no-border))
#+END_SRC

** highlight current line and no blinking cursor
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
(blink-cursor-mode 0)
(setq linum-format "%d ")
#+END_SRC

** alias for yes-or-no
This is again a quality of life thing, to allow you to hit yes or no by using y or n.
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** faster keystroke echoing
#+BEGIN_SRC emacs-lisp
(setq echo-keystrokes 0.1)
#+END_SRC

** tabs to spaces, and tab-related things
#+BEGIN_SRC emacs-lisp
(setq tab-stop-list (number-sequence 4 200 4))
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+END_SRC

** show line and column number in status bar
#+BEGIN_SRC emacs-lisp
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

** stop scrolling jumping multiple lines
#+BEGIN_SRC emacs-lisp
  (setq scroll-step           1
        scroll-conservatively 10000)
#+END_SRC

** scratch buffer - initial message
#+BEGIN_SRC emacs-lisp
  (setq-default initial-scratch-message ";; Scratch pad\n\n")
#+END_SRC

** font-locking
Replace any occurrence of 'lambda' with the actual symbol.
#+BEGIN_SRC emacs-lisp 
  (global-prettify-symbols-mode +1)
#+END_SRC

* parentheses
Show matching parens.  Use paredit to make shifting parens easier, and colourise parens using rainbow delimeters to increase visual clarity.
#+BEGIN_SRC emacs-lisp
  (show-paren-mode t)
  (require-package 'paredit)
  (require-package 'rainbow-mode)
  (require-package 'rainbow-delimiters)
  (add-hook 'prog-mode-hook 'rainbow-delimiters-mode)
#+END_SRC

* vim
Being a VIM user...Emacs' keybindings are quite nasty.  As such, I try to make this editing experience as close to the VIM experience as possible, while allowing for the nicety of Emacs.

#+BEGIN_SRC emacs-lisp
  (require-package 'evil)
  (evil-mode 1)

  (require-package 'evil-surround)
  (global-evil-surround-mode)
#+END_SRC

#+BEGIN_SRC emacs-lisp
  (define-key evil-normal-state-map (kbd "C-h") 'evil-window-left)
  (define-key evil-normal-state-map (kbd "C-j") 'evil-window-down)
  (define-key evil-normal-state-map (kbd "C-k") 'evil-window-up)
  (define-key evil-normal-state-map (kbd "C-l") 'evil-window-right)
  (define-key evil-normal-state-map (kbd "SPC") 'isearch-forward)
  (define-key evil-normal-state-map (kbd ";") 'evil-ex)
#+END_SRC

Adding key-chord here, as it's mainly for vim-type things
#+BEGIN_SRC emacs-lisp
  (require-package 'key-chord)
  (key-chord-mode 1)
  (key-chord-define-global "jk" 'evil-normal-state)
  (key-chord-define-global "gc" 'comment-or-uncomment-region)
#+END_SRC

#+RESULTS:

* backups
This is something useful to change immediately; stopping backups in the directory of the file being modified.  These are files ending in =~=, and can quickly clutter everything up.

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
#+END_SRC

Disk space is cheap. Save lots.

#+begin_src emacs-lisp
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))
#+end_src

* history

From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+begin_src emacs-lisp
(setq savehist-file "~/.emacs.d/savehist")
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))
#+end_src

* undo tree  - visualize your undos and branches

People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.
#
This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+begin_src emacs-lisp
  (require-package 'undo-tree)
  (diminish 'undo-tree-mode)
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-timestamps t)
  (setq undo-tree-visualizer-diff t)
#+end_src

* save session
#+BEGIN_SRC emacs-lisp
  (setq desktop-path (list user-emacs-directory)
        desktop-auto-save-timeout 600)
  (desktop-save-mode 1)
#+END_SRC

* project/file search - grep (and ag)
If ag is available, use that instead.  Faster.  Better for coding.
#+BEGIN_SRC emacs-lisp
  (setq-default grep-highlight-matches t
                grep-scroll-output t)

  (when *is-a-mac*
    (setq-default locate-command "mdfind"))

  (when (executable-find "ag")
    (require-package 'ag)
    (require-package 'wgrep-ag)
    (setq-default ag-highlight-search t)
    (global-set-key (kbd "M-?") 'ag-project))
#+END_SRC

#+RESULTS:
: ag-project

* show current/total matches when searching
#+BEGIN_SRC emacs-lisp
  (when (maybe-require-package 'anzu)
    (global-anzu-mode t)
    (diminish 'anzu-mode)
    (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp)
    (global-set-key [remap query-replace] 'anzu-query-replace))

  ;; DEL during isearch should edit the search string, not jump back to the previous result
  (define-key isearch-mode-map [remap isearch-delete-char] 'isearch-del-char)

#+END_SRC
* ace mode isearch
Hybrind of isearch and ace-jump.  Type a single character in search and words beginning with that will highlight.  Press the highlighted letter to jump to that occurence
#+BEGIN_SRC emacs-lisp
  (require-package 'ace-isearch)
  (global-ace-isearch-mode 1)
#+END_SRC

* smartscan
From https://github.com/itsjeyd/emacs-config/blob/emacs24/init.el

This basically allows you to do something similar to VIM *...i.e. it'll jump forward or backward to the next occurence of the symbol under the cursor.

Bound to =M-n= and =M-b= by default, I think.
#+begin_src emacs-lisp
  (require-package 'smartscan)
  (global-smartscan-mode t)
#+end_src

* utility
** help - guide-key

It's hard to remember keyboard shortcuts. The =guide-key= package pops up help after a short delay.

#+begin_src emacs-lisp
  (require-package 'guide-key)
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  (guide-key-mode 1)
#+end_src

** utf-8

From http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html
#+begin_src emacs-lisp
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+end_src

** mac osx keys
Mac needs a little bit of hand holding...
#+BEGIN_SRC emacs-lisp
  (when *is-a-mac*
    (setq mac-command-modifier 'meta)
    (setq mac-option-modifier 'none)
    (setq default-input-method "MacOSX")
#+END_SRC

Make the mouse wheel/trackpad less jerky
#+BEGIN_SRC emacs-lisp
    ;; Make mouse wheel / trackpad scrolling less jerky
    (setq mouse-wheel-scroll-amount '(1
                                      ((shift) . 5)
                                      ((control))))
    (dolist (multiple '("" "double-" "triple-"))
      (dolist (direction '("right" "left"))
        (global-set-key (kbd (concat "<" multiple "wheel-" direction ">")) 'ignore)))
#+END_SRC

And give emacs some of the expected OS X keybinds
#+BEGIN_SRC emacs-lisp
    (global-set-key (kbd "M-`") 'ns-next-frame)
    (global-set-key (kbd "M-h") 'ns-do-hide-emacs)
    (global-set-key (kbd "M-˙") 'ns-do-hide-others)
    (after-load 'nxml-mode
      (define-key nxml-mode-map (kbd "M-h") nil))
    (global-set-key (kbd "M-ˍ") 'ns-do-hide-others) ;; what describe-key reports for cmd-option-h
    (global-set-key (kbd "M-<up>") 'toggle-frame-fullscreen) ;;Bind Meta-<UP> to fullscreen toggling
    (global-set-key (kbd "<f10>") 'toggle-frame-fullscreen) ;;Bind Meta-<UP> to fullscreen toggling
)
#+END_SRC
** ibuffer - interactive buffer management
Interactively modify buffer list (jump to another buffer, see buffer modes, see full path, delete/kill buffer etc.)
#+BEGIN_SRC emacs-lisp
  (require-package 'fullframe)
  (after-load 'ibuffer
   (fullframe ibuffer ibuffer-quit))

  (require-package 'ibuffer-vc)

  (defun ibuffer-set-up-preferred-filters ()
    (ibuffer-vc-set-filter-groups-by-vc-root)
    (unless (eq ibuffer-sorting-mode 'filename/process)
      (ibuffer-do-sort-by-filename/process)))

  (add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters)



  (after-load 'ibuffer
    ;; Use human readable Size column instead of original one
    (define-ibuffer-column size-h
      (:name "Size" :inline t)
      (cond
       ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
       ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
       (t (format "%8d" (buffer-size))))))


  ;; Explicitly require ibuffer-vc to get its column definitions, which
  ;; can't be autoloaded
  (after-load 'ibuffer
    (require 'ibuffer-vc))

  ;; Modify the default ibuffer-formats (toggle with `)
  (setq ibuffer-formats
        '((mark modified read-only vc-status-mini " "
                (name 18 18 :left :elide)
                " "
                (size-h 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                filename-and-process)
          (mark modified read-only vc-status-mini " "
                (name 18 18 :left :elide)
                " "
                (size-h 9 -1 :right)
                " "
                (mode 16 16 :left :elide)
                " "
                (vc-status 16 16 :left)
                " "
                filename-and-process)))

  (setq ibuffer-filter-group-name-face 'font-lock-doc-face)

  (global-set-key (kbd "C-x C-b") 'ibuffer)

#+END_SRC

** windows - managing window splits
A useful package to prompt with a HUD, letting you to jump to a specific buffer if you have more than 2 open.

#+BEGIN_SRC emacs-lisp
  (require-package 'switch-window)
  (require 'switch-window)
  (setq switch-window-shortcut-style 'alphabet)
  (global-set-key (kbd "C-x o") 'switch-window)
#+END_SRC

When splitting windows, use the 'other'  buffer in the next window
#+BEGIN_SRC emacs-lisp
  (defun split-window-func-with-other-buffer (split-function)
    (lexical-let ((s-f split-function))
      (lambda ()
        (interactive)
        (funcall s-f)
        (set-window-buffer (next-window) (other-buffer)))))
#+END_SRC

...and key bindings to go along with this
#+BEGIN_SRC emacs-lisp
  (global-set-key "\C-x2" (split-window-func-with-other-buffer 'split-window-vertically))
  (global-set-key "\C-x3" (split-window-func-with-other-buffer 'split-window-horizontally))
#+END_SRC

And if you want to delete everything -but- this window...
#+BEGIN_SRC emacs-lisp
  (defun sanityinc/toggle-delete-other-windows ()
    "Delete other windows in frame if any, or restore previous window config."
    (interactive)
    (if (and winner-mode
             (equal (selected-window) (next-window)))
        (winner-undo)
      (delete-other-windows)))

  (global-set-key "\C-x1" 'sanityinc/toggle-delete-other-windows)
#+END_SRC
** indent after newline
#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "RET") 'newline-and-indent)
  (defun sanityinc/newline-at-end-of-line ()
    "Move to end of line, enter a newline, and reindent."
    (interactive)
    (move-end-of-line 1)
    (newline-and-indent))
#+END_SRC

** recent files

#+begin_src emacs-lisp
(require 'recentf)
(setq recentf-max-saved-items 200
      recentf-max-menu-items 15)
(recentf-mode)
#+end_src

* dired / nav

From http://www.masteringemacs.org/articles/2011/03/25/working-multiple-files-dired/

** generally improve dired appearance
#+begin_src emacs-lisp 
(require 'find-dired)
(require-package 'dired+)
(setq find-ls-option '("-print0 | xargs -0 ls -ld" . "-ld"))
#+END_SRC

** hide files beginning with .[not a dot]
#+BEGIN_SRC emacs-lisp 
  (setq dired-omit-files "^\\.[^.]\\|\\.pdf$\\|\\.tex$")
#+END_SRC

** make dired use the same buffer when switching directories.
#+BEGIN_SRC emacs-lisp 
(diredp-toggle-find-file-reuse-dir 1)
#+end_src

* word wrapping and truncation
Couldn't get this working directly...so functionalise it
#+BEGIN_SRC emacs-lisp
(defun trunc-wrap()
  "Turn on truncation and word wrapping"
  (interactive)
  (toggle-truncate-lines)
  (toggle-word-wrap))

  (key-chord-define-global "tw" 'trunc-wrap)
#+END_SRC
* prog languages
** flycheck
#+BEGIN_SRC emacs-lisp
  (require-package 'flycheck)
#+END_SRC

** markdown
Simple.  Get markdown and add to auto-list.
#+BEGIN_SRC emacs-lisp
  (require-package 'markdown-mode)

  (setq auto-mode-alist
        (cons '("\\.\\(md\\|markdown\\)\\'" . markdown-mode) auto-mode-alist))
#+END_SRC

** csv
Not done much with this yet, but generally makes CSVs a bit prettier.

#+BEGIN_SRC emacs-lisp
  (require-package 'csv-mode)
  (require-package 'csv-nav)

  (add-auto-mode 'csv-mode "\\.[Cc][Ss][Vv]\\'")

  (setq csv-separators '("," ";" "|" " "))
#+END_SRC

** html / css
Emmet is glorious for quickly outlining HTML.
#+BEGIN_SRC emacs-lisp
  (require-package 'emmet-mode)

  (add-hook 'sgml-mode-hook 'emmet-mode) ;; Auto-start on any markup modes
  (add-hook 'css-mode-hook  'emmet-mode) ;; enable Emmet's css abbreviation.

  (setq emmet-move-cursor-between-quotes t) ;; default nil
#+END_SRC

Don't know if prog-mode-hook covers HTML etc, so doing this for now.  Lazy.
#+BEGIN_SRC emacs-lisp
  (require-package 'haml-mode)
  (require-package 'sass-mode)
  (require-package 'scss-mode)
  (setq-default scss-compile-at-save t)

  ;;; Colourise CSS colour literals
  (when (maybe-require-package 'rainbow-mode)
    (dolist (hook '(css-mode-hook html-mode-hook sass-mode-hook))
      (add-hook hook 'rainbow-mode)))
#+END_SRC

#+RESULTS:

** lisp
Paredit was included earlier as it's just generally useful.

Give a default message when opening a scratch (elisp) buffer.
#+BEGIN_SRC emacs-lisp
  (setq-default initial-scratch-message
                (concat ";; Happy hacking, " (or user-login-name "") "!\n\n"))
#+END_SRC

Automatically byte-compile
#+begin_src emacs-lisp
  (require-package 'auto-compile)
  (auto-compile-on-save-mode 1)
  (auto-compile-on-load-mode 1)
#+end_src

and load the .el if it's newer than the .elc
#+begin_src emacs-lisp
  (setq load-prefer-newer t)
#+end_src

Allow code to auto-update (elisp only)
#+begin_src emacs-lisp
  (require-package 'lively)
#+end_src

Hook some useful settings into lisp modes
#+begin_src emacs-lisp
  (defun davison/useful-lisp ()
    (rainbow-delimiters-mode t)
    (enable-paredit-mode)
    (when (fboundp 'aggressive-indent-mode)
      (aggressive-indent-mode)))

  (add-hook 'lisp-mode 'davison/useful-lisp)
  (add-hook 'emacs-lisp-mode 'davison/useful-lisp)
#+end_src

** racket
#+BEGIN_SRC emacs-lisp
  (require-package 'racket-mode)
  (put 'test-case 'racket-indent-function 1)
  (add-hook 'racket-mode-hook 'paredit-mode)
#+END_SRC

Bind the required programs...
#+BEGIN_SRC emacs-lisp
  (setq racket-racket-program "/usr/local/bin/racket")
  (setq racket-raco-program "/usr/local/bin/raco")

  (setq racket-program "/usr/local/bin/racket")
  (setq raco-program "/usr/local/bin/raco")
#+END_SRC

** go
Format code when saving
#+BEGIN_SRC emacs-lisp
  (require-package 'go-mode)
  (require-package 'go-autocomplete)

  (add-hook 'before-save-hook 'gofmt-before-save)
#+END_SRC

** rust
#+BEGIN_SRC emacs-lisp
  (require-package 'rust-mode)
  (require-package 'flymake-rust)
  (require-package 'flycheck-rust)
#+END_SRC

** QUOTE python
Use python3 by default, and install EmacsIPythonNotebook (ein)
#+BEGIN_SRC emacs-lisp 
  (require-package 'virtualenvwrapper)
  (venv-initialize-interactive-shells) ;; if you want interactive shell support
  (venv-initialize-eshell) ;; if you want eshell support
  (setq venv-location "/Users/davison/Envs/")

  (require-package 'ein)
#+END_SRC

Automatically run on numeric environment when using python
#+BEGIN_SRC emacs-lisp 
  (add-hook 'python-mode-hook (lambda ()
                                  (venv-workon "numeric")))
#+END_SRC
** c / c++
#+BEGIN_SRC emacs-lisp
  (add-hook 'c-mode-common-hook
    (lambda()
      (local-set-key (kbd "C-c <right>") 'hs-show-block)
      (local-set-key (kbd "C-c <left>")  'hs-hide-block)
      (local-set-key (kbd "C-c <up>")    'hs-hide-all)
      (local-set-key (kbd "C-c <down>")  'hs-show-all)
      (hs-minor-mode t)))
#+END_SRC
* ido
#+BEGIN_SRC emacs-lisp
  (require 'ido)
  (ido-mode t)
  (ido-everywhere t)
  (setq ido-enable-flex-matching t)
  (setq ido-use-filename-at-point nil)
  (setq ido-auto-merge-work-directories-length 0)
  (setq ido-use-virtual-buffers t)

  (when (maybe-require-package 'ido-ubiquitous)
    (ido-ubiquitous-mode t))

  ;; Use smex to handle M-x
  (when (maybe-require-package 'smex)
    ;; Change path for ~/.smex-items
    (setq smex-save-file (expand-file-name ".smex-items" user-emacs-directory))
    (global-set-key [remap execute-extended-command] 'smex))

  (require-package 'idomenu)

  ;; Allow the same buffer to be open in different frames
  (setq ido-default-buffer-method 'selected-window)
#+END_SRC

* org-mode
** taking notes
Use a dropbox folder as my org-mode folder, and set up a default org mode file in here...
#+BEGIN_SRC emacs-lisp
  (setq org-directory "~/Dropbox/org")
  (setq org-default-notes-file "~/Dropbox/org/notes.org")
#+END_SRC

This makes it easier to add links from outside.

#+begin_src emacs-lisp
(defun sacha/yank-more ()
  (interactive)
  (insert "[[")
  (yank)
  (insert "][more]]"))
(global-set-key (kbd "<f6>") 'sacha/yank-more)
#+end_src

** editing source code
   When using C-c ', don't change to another window. 
#+begin_src emacs-lisp
  (setq org-src-window-setup 'current-window)
  (setq org-src-fontify-natively t)
#+end_src
  
** publishing
Timestamps and section numbers make my published files look more
complicated than they are. Let's turn them off by default.

#+begin_src emacs-lisp
(setq org-export-with-section-numbers nil)
(setq org-html-include-timestamps nil)
#+end_src

** refiling
   =org-refile= lets you organize notes by typing in the headline to file them under.
#+begin_src emacs-lisp
  (setq org-reverse-note-order t)
  (setq org-refile-use-outline-path nil)
  (setq org-refile-allow-creating-parent-nodes 'confirm)
  (setq org-refile-use-cache nil)
  (setq org-refile-targets '((org-agenda-files . (:maxlevel . 6))))
  (setq org-blank-before-new-entry nil)
#+end_src

** templates
   =org-capture= lets you create templates for jotting down info of various kinds.  Here is some structure...

Function for setting up templates
#+begin_src emacs-lisp
    (defvar sacha/org-basic-task-template "* TODO %^{Task}
    SCHEDULED: %^t
    :PROPERTIES:
    :Effort: %^{effort|1:00|0:05|0:15|0:30|2:00|4:00}
    :END:
    %?
    " "Basic task data")
#+END_SRC
   

And the actual templates
#+BEGIN_SRC emacs-lisp
    (setq org-capture-templates
          `(("t" "Tasks" entry
             (file+headline "~/Dropbox/org/notes.org" "Tasks")
             ,sacha/org-basic-task-template)
            ("T" "Quick task" entry
             (file+headline "~/Dropbox/org/notes.org" "Tasks")
             "* TODO %^{Task}"
             :immediate-finish t)
            ("q" "Quick note" item
             (file+headline "~/Dropbox/org/notes.org" "Quick notes"))
             ("c" "Contact" entry (file "~/Dropbox/org/contacts.org")
              "* %(org-contacts-template-name)
    :PROPERTIES:
    :EMAIL: %(org-contacts-template-email)
    :END:")
             ("n" "Daily note" table-line (file+olp "~/Dropbox/org/notes.org" "Daily notes")
              "| %u | %^{Note} |"
              :immediate-finish t)
             ("r" "Notes" entry
              (file+datetree "~/Dropbox/org/notes.org")
              "* %?\n\n%i\n"
              )))
#+end_src

#+RESULTS:
| t | Tasks      | entry      | (file+headline ~/Dropbox/org/notes.org Tasks)       | * TODO %^{Task}\nSCHEDULED: %^t\n:PROPERTIES:\n:Effort: %^{effort                            | 1:00              | 0:05     | 0:15 |              0:30 | 2:00 | 4:00}\n:END:\n%?\n |
| T | Quick task | entry      | (file+headline ~/Dropbox/org/notes.org Tasks)       | * TODO %^{Task}                                                                              | :immediate-finish | t        |      |                   |      |                    |
| q | Quick note | item       | (file+headline ~/Dropbox/org/notes.org Quick notes) |                                                                                              |                   |          |      |                   |      |                    |
| c | Contact    | entry      | (file ~/Dropbox/org/contacts.org)                   | * %(org-contacts-template-name)\n:PROPERTIES:\n:EMAIL: %(org-contacts-template-email)\n:END: |                   |          |      |                   |      |                    |
| n | Daily note | table-line | (file+olp ~/Dropbox/org/notes.org Daily notes)      |                                                                                              | %u                | %^{Note} |      | :immediate-finish |    t |                    |
| r | Notes      | entry      | (file+datetree ~/Dropbox/org/notes.org)             | * %?\n\n%i\n                                                                                 |                   |          |      |                   |      |                    |

** agenda
#+BEGIN_SRC emacs-lisp
  (setq org-agenda-files
        (delq nil
              (mapcar (lambda (x) (and (file-exists-p x) x))
                      '("~/Dropbox/org/"))))
#+END_SRC

** update checkboxes on save
  
#+BEGIN_SRC emacs-lisp 
  (defun checkbox-before-save ()
    (org-update-checkbox-count t))

  (add-hook 'org-mode-hook 
            (lambda () 
               (add-hook 'before-save-hook 'checkbox-before-save nil 'make-it-local)))
#+END_SRC 

** todo keywords

#+BEGIN_SRC emacs-lisp 
  (setq org-todo-keywords
           '((sequence "-TODO-(t)" "-WIP(w)-" "|" "-DONE(d)-" "-CANCELLED-(c)"))) 
#+END_SRC

** keyboard shortcuts

#+begin_src emacs-lisp
    (global-set-key (kbd "<f1>") 'org-capture)
    (global-set-key (kbd "<f2>") 'org-agenda)
    (global-set-key (kbd "<f3>") 'org-agenda-list)
    (global-set-key (kbd "<f4>") 'org-timeline)
#+end_src

   
Links to common files
#+BEGIN_SRC emacs-lisp 
  (global-set-key (kbd "C-x j") 'jump-to-register)
  (set-register ?c (cons 'file "~/.emacs.d/Chris.org"))
  (set-register ?u (cons 'file "~/Dropbox/org/uni.org"))
  (set-register ?n (cons 'file "~/Dropbox/org/notes.org"))
  (set-register ?r (cons 'file "~/Dropbox/org/rust.org"))
  (set-register ?w (cons 'file "~/Dropbox/org/wh40k.org"))
  (set-register ?d (cons 'file "~/Dropbox/org/dungeon-world.org"))
  (set-register ?j (cons 'file "~/Dropbox/org/clojure.org"))
  (set-register ?m (cons 'file "~/Dropbox/org/numenera.org"))
  (set-register ?s (cons 'file "~/Dropbox/org/scrolls.org"))
  (set-register ?t (cons 'file "~/.tmp.org"))
#+END_SRC

* helm
** general helm setup
#+BEGIN_SRC emacs-lisp
  (require-package 'helm)
  (require 'helm-config)
  (setq helm-candidate-number-limit 10)
  (setq helm-idle-delay 0.0 ; update fast sources immediately (doesn't).
              helm-input-idle-delay 0.01  ; this actually updates things
                                            ; reeeelatively quickly.
              helm-quick-update t
              helm-M-x-requires-pattern nil
              helm-ff-skip-boring-files t)
  (helm-mode)
#+END_SRC

** key bindings
#+BEGIN_SRC emacs-lisp 
  (global-set-key (kbd "C-c h") 'helm-mini)
  (global-set-key (kbd "C-p") 'helm-mini)
  (global-set-key (kbd "C-c a") 'helm-apropos)
  (global-set-key (kbd "C-c o") 'helm-occur)
  (global-set-key (kbd "C-c s") 'helm-swoop)
  (global-set-key (kbd "C-c i") 'helm-imenu)

  (global-set-key (kbd "M-y") 'helm-show-kill-ring)
  (ido-mode -1)
#+END_SRC
   
** describe bindings
#+BEGIN_SRC emacs-lisp 
  (require-package 'helm-descbinds)
  (global-set-key (kbd "C-c b") 'helm-descbinds)
#+END_SRC
   

