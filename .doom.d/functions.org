#+TITLE: Custom Functions
#+PROPERTY: header-args :tangle "functions.el" :results silent

* Timestamp helpers

#+BEGIN_SRC emacs-lisp
(defun insert-formatted-time (format)
  "Insert a timestamp matching a specific format"
  (insert (format-time-string format (current-time))))

(defun insert-timestamp-long ()
  "Insert a LONG timestamp"
  (interactive)
  (insert-formatted-time "%a %b %d %H:%M:%S %Z %Y"))

(defun insert-timestamp-date ()
  "Insert a plain date"
  (interactive)
  (insert-formatted-time "%Y-%m-%d"))

(defun insert-timestamp-time ()
  "Insert a plain timestamp"
  (interactive)
  (insert-formatted-time "%H:%M:%S"))
#+END_SRC


* Repoutil

Wrapper around my =repoutil= git managing utility.
#+BEGIN_SRC emacs-lisp
(defun repoutil (command)
  (cd/shell-command-to-special-buf
   (format "repoutil %s" command)
   "*repoutil*"))
(set-popup-rule! "^\\*repoutil\\*" :side 'bottom :size 0.30 :select t :ttl 1)

(defun cd/shell-command-to-special-buf (command bufname)
  (get-buffer-create bufname)
  (message (format "Running: %s" command))
  (shell-command command bufname)
  (switch-to-buffer-other-window bufname)
  (special-mode)
  (evil-insert 1))

(defun repoutil-branchstat () (interactive) (repoutil "branchstat"))

(defun repoutil-list () (interactive) (repoutil "list"))

(defun repoutil-fetch () (interactive) (repoutil "fetch") (quit-window))

(defun repoutil-unclean () (interactive) (repoutil "unclean"))
#+END_SRC

* Tagsearch

** List tags for all files under the current directory
#+BEGIN_SRC emacs-lisp
(defun tagsearch-list (&optional tags)
  "List tags under the current directory.

When optional TAGS is a string, show only files matching those tags"
  (interactive)
  (let ((cmd (concat "tagsearch " (or tags "")))
        (temp-buf-name "*tagsearch*"))
    (get-buffer-create temp-buf-name)
    (shell-command cmd temp-buf-name)
    (switch-to-buffer-other-window temp-buf-name)
    (special-mode)
    (evil-insert 1)))
#+END_SRC

Also, make tagsearch only take up the bottom 30% of the screen in a special doom popup window.
#+BEGIN_SRC emacs-lisp
(set-popup-rule! "^\\*tagsearch" :side 'bottom :size 0.30 :select t :ttl 1)
#+END_SRC

** Find files in directory that contain a tag
#+BEGIN_SRC emacs-lisp
(defun files-matching-tagsearch (&optional tags directory)
  (interactive)
  (let* ((directory (if directory directory (read-directory-name "DIR: ")))
         (cmd (format "tagsearch %s" (if tags tags (read-string "Tags: "))))
         (fullcmd (format "cd %s && %s" directory cmd))
         (output (s-split "\n" (s-trim (shell-command-to-string fullcmd)))))
    (--map (f-join directory it) output)))
#+END_SRC

** Find files in directory that contain a tag, and show
#+BEGIN_SRC emacs-lisp
(defun files-matching-tagsearch (&optional tags directory)
  (interactive)
  (let* ((directory (if directory directory (read-directory-name "DIR: ")))
         (cmd (format "tagsearch %s | grep -v archive" (if tags tags (read-string "Tags: "))))
         (fullcmd (format "cd %s && %s" directory cmd))
         (output (s-split "\n" (s-trim (shell-command-to-string fullcmd)))))

    (get-buffer-create "*tagsearch*")
    (shell-command fullcmd "*tagsearch*")
    (switch-to-buffer-other-window "*tagsearch*")
    (special-mode)
    (evil-insert 1)))
#+END_SRC
* Ripgrep (=rg=) in specific locations

#+BEGIN_SRC emacs-lisp
(defun rg-journal (search)
  (interactive "Msearch string: ")
  (let ((filename (format-time-string "journal-%Y.org")))
    (rg search filename "~/code/knowledge")))

(defun rg-logbook (search)
  (interactive "Msearch string: ")
  (let ((filename (format-time-string "logbook-%Y.org")))
    (rg search filename "~/code/knowledge")))

(defun rg-org (search)
  (interactive "Msearch string: ")
  (rg search "org" org-directory))
#+END_SRC

* Git

** List files that have been updated/created in last N days

#+BEGIN_SRC emacs-lisp
(defun new-in-git ()
  (interactive)
  (get-buffer-create "*new-in-repo*")
  (shell-command "new_in_git 1" "*new-in-repo*")
  (switch-to-buffer-other-window "*new-in-repo*")
  (special-mode))
(set-popup-rule! "^\\*new-in-repo\\*" :side 'bottom :size 0.30 :select t :ttl 1)
#+END_SRC

* Easier SSH to work servers

#+BEGIN_SRC emacs-lisp
(defun cd/extract-ssh-connection (&optional name)
  (if (boundp 'my-remote-servers)
      ;; my-remote-servers should be a plist of (SERVER :username USER :ip IP)
      (let* ((selected (if name name (completing-read "Server: " (mapcar 'car my-remote-servers) nil t)))
             (data (cdr (assoc selected my-remote-servers)))
             (username (plist-get data :username))
             (ip (plist-get data :ip))
             (hop (plist-get data :hop)))
        `(,username ,ip ,hop))
    ;; otherwise, read a username and an ip
    (let ((username (read-string "Username: "))
          (ip (read-string "ip: "))
          (hop nil))
      `(,username ,ip ,hop))))

(defun connect-remote ()
  (interactive)
  (let* ((data (cd/extract-ssh-connection))
         (username (car data))
         (folder (if (string= username "root") "/" (format "/home/%s/" username)))
         (ip (car (cdr data)))
         (hop (car (cdr (cdr data))))
         (hopdata (if hop (cd/extract-ssh-connection hop) nil))
         (hopstr (if hopdata (format "sshx:%s@%s|"
                                     (car hopdata)
                                     (car (cdr hopdata)))
                   ""))
         (connstr (format "sshx:%s@%s" username ip))
         (conn (format "/%s%s:%s" hopstr connstr folder)))
    (dired conn)))
#+END_SRC

* NAS helper scripts


Add the current clip to the download list. Will parse a url if it is like an org-mode link.
#+BEGIN_SRC emacs-lisp
(defun nas/quick-add-download ()
  "Add contents of clipboard to nas' to-download file."
  (interactive)
  (let* ((path "/media/nas/to-download.txt")
         (clip (s-trim (current-kill 0)))
         (re-org-url "\\[\\[\\(.*\\)\\]\\[.*\\]\\]")
         (matches (s-match re-org-url clip))
         (url (if matches (cadr matches) clip))
         (url-tidy (if (s-matches? "youtube\\|youtu\.be" url)
                       (car (s-split "&" url))
                     url))
         (contents (s-split "\n" (read-file-to-string path))))
    (pushnew! contents url-tidy)
    (delete-dups contents)
    (write-region (s-join "\n" contents) nil path)
    (message (concat "Added to downloads: " url-tidy))))


#+END_SRC

List the downloads that haven't been pulled yet.
#+BEGIN_SRC emacs-lisp
(defun nas/list-downloads ()
  "List contents of NAS 'to-download' list."
  (interactive)
  (let* ((path "/media/nas/to-download.txt")
         (temp-buf-name "*nas-downloads*"))
    (get-buffer-create temp-buf-name)
    (switch-to-buffer-other-window temp-buf-name)
    (insert "NAS DOWNLOADS\n=============\n")
    (insert-file-contents path)
    (special-mode)
    (evil-insert 1)))
(set-popup-rule! "^\\*nas-downloads*" :side 'bottom :size 0.30 :select t :ttl 1)
#+END_SRC
* Narrows

#+BEGIN_SRC emacs-lisp
;;; Navigate narrows
(defun change-narrow (direction)
  (interactive)
  (progn
    (beginning-of-buffer)
    (widen)
    (if (eq direction 'prev)
        (outline-previous-heading)
      (outline-next-heading))
    (org-narrow-to-subtree)))

(defun move-to-previous-narrow ()
  (interactive)
  (change-narrow 'prev))

(defun move-to-next-narrow ()
  (interactive)
  (change-narrow 'next))
#+END_SRC
* Iterate files in a directory

#+BEGIN_SRC emacs-lisp
(defun find-next-file (&optional backward)
  "Find the next file (by name) in the current directory.

With prefix arg, find the previous file."
  (interactive "P")
  (when buffer-file-name
    (let* ((file (expand-file-name buffer-file-name))
           (files (cl-remove-if (lambda (file) (cl-first (file-attributes file)))
                                (sort (directory-files (file-name-directory file) t nil t) 'string<)))
           (direction (if backward -1 1))
           (pos (mod (+ (cl-position file files :test 'equal) direction)
                     (length files))))
      (find-file (nth pos files)))))

(defun find-previous-file ()
  "Find the next file (by name) in the current directory."
  (interactive)
  (find-next-file t))

(defun files-in-curdir-with-ext (ext)
  (let* ((curdir (expand-file-name default-directory))
         (files (directory-files curdir)))
    (seq-filter
     (lambda (filename)
       (s-equals? ext (file-name-extension filename)))
     (-map (lambda (file) (s-concat curdir file)) files))))
#+END_SRC
* Get notes from last N days

For a 'weekly review' of sorts.

Basically, =cat= the contents of each 'thought', and also add in all files in my note dir that have been modified or added within the last N days (default 7).

#+begin_src emacs-lisp
(defun cd/notes-from-last-n-days (&optional n)
  (interactive)
  (require 'ts)
  (let* ((n (if n n 7))
         (files (find-lisp-find-files (f-join org-directory "thoughts") "\.org$"))
         (date-n-ago (ts-format "%F" (ts-adjust 'day (- 0 n) (ts-now))))
         (files-last-n (--filter (string-greaterp (car (s-split "--" (file-name-base it))) date-n-ago)
                                 files))
         (sorted-files (sort files-last-n 'string-lessp))
         (bufname "*recent-notes*"))
    (get-buffer-create bufname)
    (switch-to-buffer-other-window bufname)
    (erase-buffer)
    (org-mode)
    (insert "* Git Additions\n\n")
    (let ((curdir default-directory))
      (cd org-directory)
      (insert (shell-command-to-string (format "new_in_git %d" n)))
      (cd curdir))
    (insert "\n")
    (--each sorted-files (insert-file it))))

(defun cd/notes-from-last-week ()
  (interactive)
  (cd/notes-from-last-n-days 7))

(defun cd/notes-from-yesterday ()
  (interactive)
  (cd/notes-from-last-n-days 1))
#+end_src
* Inserting tags

#+begin_src emacs-lisp
;;; Tags (like tagsearch or roam)
(defun tagify (str)
  (interactive "M")
  (s-join " " (--map (format "@%s" it) (s-split " " str))))

(defun roam-tagify (str)
  (interactive "Mtags: ")
  (evil-open-below 1)
  (insert (format "#+ROAM_TAGS: %s\n\n" str))
  (insert (tagify str))
  (evil-force-normal-state)
  (save-buffer))

(defun roam-tagify-toplevel (str)
  (interactive "Mtags: ")
  (evil-goto-first-line)
  (evil-insert-line 1)
  (insert (s-concat "#+ROAM_TAGS: " (tagify str) "\n\n"))
  (evil-force-normal-state)
  (save-buffer))
#+end_src

* Handle 'asset' directories

Asset directories are a single location within a repo (typically my =org-directory=) that contain stuff like images I want inlined in my notes.
#+BEGIN_SRC emacs-lisp
(defun get-asset-dir ()
  (interactive)
  (let ((maybe-asset-dir (f-join (projectile-project-root) "assets")))
    (if (f-readable? maybe-asset-dir)
        maybe-asset-dir
      "./assets")))

(defun get-relative-asset-dir ()
  (interactive)
  (file-relative-name (get-asset-dir)
                      (buffer-file-name)))
#+END_SRC
* Lists and checkbox lists

#+begin_src emacs-lisp
;;; Lists and checkboxes
(defun make-into-list ()
  "Basically equivalent to org-ctrl-c-minus."
  (interactive)
  (replace-regexp "^" "- " nil (region-beginning) (region-end)))

(defun make-into-checkbox-list ()
  "Convert selection to list (only at root level) of checkboxes."
  (interactive)
  (let ((re (rx bol (zero-or-one "-") (one-or-more space))))
    (replace-regexp re "- [ ] " nil (region-beginning) (region-end))))
#+end_src
* Summarise my cycling training

#+begin_src emacs-lisp
(defun cd/cycling-tss-summary ()
  (interactive)
  (let* ((fname (f-join org-directory "fitness" "cycling.org"))
         (contents (s-split "\n" (read-file-to-string fname)))
         (matching (--filter (or (s-matches? "[0-9]+ W[0-9]+" it)
                                 (s-matches? "Total.*stress" it))
                             contents))
         (pairs (map-pairs matching))
         (tidied (--map `(,(s-replace-regexp "^\*+ +" "" (car it))
                          ,(s-replace-regexp ".*:: +" "" (cdr it)))
                        pairs))
         (strings (--map (format "%s -- TSS %s" (car it) (cadr it))
                         tidied))
         (joined (s-join "\n" strings))
         (header "Cycling -- TSS per week (from cycling.org)")
         (underline (s-repeat (length header) "=")))
    (cd/string-to-special-buffer (s-join "\n" `(,header ,underline ,joined)) "*cycling-tss*")))
#+end_src
* Insert string into special buffer

#+begin_src emacs-lisp
(defun cd/string-to-special-buffer (contents bufname)
  (interactive)
  (kill-buffer bufname)                 ;
  (get-buffer-create bufname)
  (switch-to-buffer-other-window bufname)
  (kill-region (point-min) (point-max))
  (insert contents)
  (special-mode)
  (evil-insert 1))
#+end_src

* UNFILED

#+BEGIN_SRC emacs-lisp
(defun read-file-to-string (filePath)
  "Return filePath's file content."
  (with-temp-buffer
    (insert-file-contents filePath)
    (buffer-string)))

(defun erase-all-matches-from-start (regex)
  (replace-regexp regex "" nil (point-min) (point-max)))

;;; UNORGANISED
(defun zsh ()
  (interactive)
  (term "/usr/bin/zsh"))

(defun elpy-send-contiguous-block ()
  (interactive)
  (mark-paragraph)
  (elpy-shell-send-region-or-buffer)
  (evil-forward-paragraph))

;;; Emacs lisp
(defun eval-into-comment ()
  (interactive)
  (let ((sexp (elisp--preceding-sexp)))
    (save-excursion
      (goto-char (line-end-position))
      (delete-horizontal-space)
      (insert " ;; " (prin1-to-string (eval sexp))))))
#+END_SRC

This currently doesn't work in my WSL setup.
#+begin_src emacs-lisp :tangle no
(defun cd/search-vocab ()
  (interactive)
  (let ((word (read-string "Word: "))
        (lang (read-string "Language: "))))
  (shell-command (s-join " " '("~/code/scripts/ankivocab.py" word lang))))
#+end_src
