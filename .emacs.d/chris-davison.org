#+title: Chris Davison's Emacs Config
#+PROPERTY: header-args emacs-lisp :tangle yes :results silent

This configuration uses =org-babel= to tangle this =org= file into an =el= file which is loaded in =init.el=. /Tangle/ this file using =C-c C-v t=, and then use =(load "chris-davison.el" t)= inside =init.el=.

Set up my 'identity'.
#+BEGIN_SRC emacs-lisp
(setq
 user-full-name "Chris Davison"
 user-mail-address "c.jr.davison@gmail.com"
 user-emacs-directory "~/code/dotfiles/.emacs.d"
 config-file (expand-file-name "chris-davison.org" user-emacs-directory))
#+END_SRC

* Configure package management
This sets up the load path so that we can override it.  We also install /use-package/ to make all package config easier.
#+BEGIN_SRC emacs-lisp
(package-initialize)

;; (setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.2")

(package-refresh-contents)

(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

(setq package-enable-at-startup t)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(setq-default use-package-enable-imenu-support t)
(setq use-package-always-ensure t)
(eval-when-compile (require 'use-package))
(setq lexical-binding t)

(setq load-path (append (list (expand-file-name "~/.emacs.d/elisp")) load-path))
(require 'breadcrumb)
#+END_SRC

* Minor tweaks
Generally useful common-lisp library (functions)
#+BEGIN_SRC emacs-lisp
(use-package cl-lib :ensure t :config (require 'cl-lib))
(use-package s :ensure t)  ; Useful string functions
(use-package f :ensure t)  ; Useful file and dir functions
(use-package diminish :ensure t)
#+END_SRC

Make =apropos= bring up all help, rather than requiring separate keybinds
#+BEGIN_SRC emacs-lisp
(setq apropos-do-all t)
#+END_SRC

Simplify keys needed for /yes or no/ prompt
#+BEGIN_SRC emacs-lisp
(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

Make list-packages take up the full frame
#+BEGIN_SRC emacs-lisp
(use-package fullframe :ensure t
  :config (fullframe list-packages quit-window))
#+END_SRC

Try to make everything UTF8. From [[http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html][here]]
#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC
* History (sessions and file history)
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups"))
      delete-old-versions -1
      version-control t
      vc-make-backup-files t
      auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

;; Save minibuffer and other history
(setq savehist-file (expand-file-name "savehist" user-emacs-directory)
      history-length t
      history-delete-duplicates t
      savehist-save-minibuffer-history 1
      savehist-additional-variables '(kill-ring
                                      search-ring
                                      regexp-search-ring))
(savehist-mode 1)

;; Counting 'recent files' as part of history
(use-package recentf :ensure t
  :config
  (setq recentf-max-saved-items 200
        recentf-max-menu-items 15)
  (recentf-mode))

;; Always save the desktop, the current workspace config
(setq desktop-path (list user-emacs-directory)
      desktop-auto-save-timeout 600
      desktop-restore-frames nil) ; desktop-store-frames will keep themes loaded
(desktop-save-mode 1)

;; Reload when file changed on disk
(setq auto-revert-verbose nil)
(global-auto-revert-mode t)

;; Don't create lockfiles.  They're often a hassle
(setq create-lockfiles nil)
#+END_SRC

* Magit - Git in Emacs
#+BEGIN_SRC emacs-lisp
(use-package magit :ensure t
  :config
  (setq
   ;; Magit needs to call git multiple times
   ;; only refreshing the  buffer can improve performance
   magit-refresh-status-buffer nil
   ;; Emacs has its own version control.  We don't need to run both
   ;; as that'll be detrimental for performance
   vc-handled-backends (delq 'Git vc-handled-backends))
  :bind (("C-x g" . magit-status)))

(use-package forge
  :after magit)
#+END_SRC

A better magit status. Only show magit, and if the currently active file had changes, go to it's unstaged changes section.
#+begin_src emacs-lisp
(defun unpackaged/magit-status ()
  "Open a `magit-status' buffer and close the other window so only Magit is visible.
If a file was visited in the buffer that was active when this
command was called, go to its unstaged changes section."
  (interactive)
  (let* ((buffer-file-path (when buffer-file-name
                             (file-relative-name buffer-file-name
                                                 (locate-dominating-file buffer-file-name ".git"))))
         (section-ident `((file . ,buffer-file-path) (unstaged) (status))))
    (magit-status)
    (delete-other-windows)
    (when buffer-file-path
      (goto-char (point-min))
      (cl-loop until (when (equal section-ident (magit-section-ident (magit-current-section)))
                       (magit-section-show (magit-current-section))
                       (recenter)
                       t)
               do (condition-case nil
                      (magit-section-forward)
                    (error (cl-return (magit-status-goto-initial-section-1))))))))
#+end_src
* Utility functions
** Files - rename or delete, and update buffer
#+begin_src emacs-lisp
(defun rename-this-buffer-and-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name))
        (read-file-name-function 'read-file-name-default))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

(defun delete-this-buffer-and-file (force)
  "Delete the file connected to this buffer and kill it, FORCE is universal argument."
  (interactive "P")
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "'%s' is not a file buffer" name)
      (when (or force (yes-or-no-p (format  "Delete '%s', Are you sure? " filename)))
        (delete-file filename)
        (kill-buffer buffer)
        (message "Deleted '%s'" filename)))))
#+end_src
** Detect windows OS
This is a bit of a cludge to handle both windows and WSL.
#+BEGIN_SRC emacs-lisp
(defvar is-windows?
  (or (eq system-type 'windows-nt)
      (string-match "/mnt/" (getenv "PATH"))
      (string-match "Windows" (getenv "PATH"))))

(defvar is-wsl?
   (and is-windows? (s-matches? "Linux" (shell-command-to-string "uname -a"))))

#+END_SRC
** Echo path of the current file
#+BEGIN_SRC emacs-lisp
(defun filepath ()
  "Echo the filepath as a message."
  (interactive)
  (message (buffer-file-name)))
#+END_SRC

** Delete the current file
#+BEGIN_SRC emacs-lisp
(defun delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (or (buffer-file-name) (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))
#+END_SRC
** Jump to file in my notes dir
#+BEGIN_SRC emacs-lisp
(defun notes ()
  (interactive)
  (counsel-file-jump "" "~/Dropbox/notes"))
(global-set-key (kbd "C-c n") 'notes)
#+END_SRC
* Editing
** General Editing Config
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)

(setq find-file-visit-truename t)

;; transparently open compressed files
(auto-compression-mode t)

;; Don't double-space sentences
(set-default 'sentence-end-double-space nil)

;; Use lettercase to determine words in camelcase text
(global-subword-mode 1)
(diminish 'subword)

;; expand region
(use-package expand-region :ensure t)
(global-set-key (kbd "C-=") 'er/expand-region)

;; If a region is selected, any 'insert' command (typing or yanking) will overwrite it, rather than inserting before.
(delete-selection-mode 1)

;; indent after newline
(global-set-key (kbd "RET") 'newline-and-indent)

;; Interactive editing...over word or region, C-; to edit. Just modify
;; the symbol, then repeat C-; to exit.
(use-package iedit :ensure t)
(global-set-key (kbd "C-;") 'iedit-mode)

;; snippets
(use-package yasnippet :demand t :diminish)
(when (fboundp 'yas-global-mode)
  (yas-global-mode +1))
(diminish 'yas-minor-mode)
(use-package yasnippet-snippets :demand t)

(add-hook 'before-save-hook 'delete-trailing-whitespace)

(global-set-key (kbd "C-S-SPC") 'cycle-spacing)
#+END_SRC

** Text filling (paragraph reflowing) and indentation
#+BEGIN_SRC emacs-lisp
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and make it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))

(use-package aggressive-indent :ensure t
  :config (global-aggressive-indent-mode))
#+END_SRC

** Create parent dirs on file write
[[http://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/][From this blog]]
#+BEGIN_SRC emacs-lisp

(defun my-create-non-existent-directory ()
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions 'my-create-non-existent-directory)
#+END_SRC
** Header templates per filetype
Use ~auto-insert~ when in a new file of that kind to insert header.
#+BEGIN_SRC emacs-lisp
(setq auto-insert-alist
      '(((emacs-lisp-mode . "Emacs lisp mode") nil
         ";;; " (file-name-nondirectory buffer-file-name) " --- " _ "\n\n"
         ";;; Commentary:\n\n"
         ";;; Code:\n\n"
         "(provide '" (substring (file-name-nondirectory buffer-file-name) 0 -3) ")\n"
         ";;; " (file-name-nondirectory buffer-file-name) " ends here\n")
        ((c-mode . "C program") nil
         "/*\n"
         " * File: " (file-name-nondirectory buffer-file-name) "\n"
         " * Description: " _ "\n"
         " */\n\n")
        ((shell-mode . "Shell script") nil
         "#!/bin/bash\n\n"
         " # File: " (file-name-nondirectory buffer-file-name) "\n"
         " # Description: " _ "\n\n")
        ((org-mode . "Org mode") nil
         "#+TITLE: " (read-string "Title: ") "\n"
         "#+AUTHOR: Chris Davison\n"
         "#+EMAIL: c.jr.davison@gmail.com\n"
         "#+OPTIONS: toc:2 num:nil html-postamble:nil\n"
         "#+PROPERTY: header-args :tangle " (read-string "Tangle filename: ") "\n")
        ((python-mode . "Python") nil
         "#!/usr/bin/env python3")
        ((awk-mode . "Awk") nil
         "#!/usr/bin/awk -f"
         "{"
         "    /* ACTION */"
         "    $0"
         "}"
         "END { "
         "    /* AFTER-ACTION */"
         "}")
        ))
#+END_SRC
** TODO Multiple cursors
Use multiple cursors

#+BEGIN_SRC emacs-lisp :tangle no
(use-package multiple-cursors :ensure t
  :hook ((prog-mode . multiple-cursors-mode)))
#+END_SRC

** Clear modification flag after saving
This is a bit of a hack to get around my current problem of the modification flag staying set, even after saving, meaning I need to visit buffers and manually toggle.

This function is just a wrapper around ~save-buffer~, to follow that call with a modification flag clear.

#+BEGIN_SRC emacs-lisp
(defun save-buffer-and-clear-modify ()
  (interactive)
  (save-buffer)
  (set-buffer-modified-p nil))
(global-set-key (kbd "C-x C-s") 'save-buffer-and-clear-modify)
#+END_SRC
** Undo Tree - Visualise branches of undos
People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.

This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree :ensure t :diminish
  :config
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-timestamps nil
        undo-tree-visualizer-diff t))
#+END_SRC

* isearch -- live preview of search and replace
#+BEGIN_SRC emacs-lisp
;; Show current and total matches while searching
(use-package anzu :ensure t :diminish
  ;; Replace and regexp-replace are inverted, as I regexp-replace more
  :bind (([remap query-replace] . anzu-query-replace-regexp)
         ([remap query-replace-regexp] . anzu-query-replace))
  :config (global-anzu-mode t))

;; DEL during isearch should edit the search string, not jump back to the previous result
(define-key isearch-mode-map [remap isearch-delete-char] 'isearch-del-char)

(setq search-whitespace-regexp "[ \t\r\n-_]+")
#+END_SRC

* Platform-specific
** OSX
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (use-package exec-path-from-shell :ensure t
    :config
    (when (memq window-system '(mac ns))
      (exec-path-from-shell-initialize))
    (exec-path-from-shell-copy-env "GOPATH"))

  (setq mac-command-modifier 'meta
        mac-option-modifier 'none
        default-input-method "MacOSX")
  (global-set-key (kbd "<f10>") 'toggle-frame-fullscreen))
#+END_SRC

** Windows - use git bash as shell, and fix shell settings
Use git-bash as windows shell
#+BEGIN_SRC emacs-lisp
(when (and is-windows? (not (s-matches? "Linux" (shell-command-to-string "uname -a"))))
  (progn (setq explicit-shell-file-name
               "C:/Program Files/Git/bin/sh.exe"
               shell-file-name "bash"
               explicit-sh.exe-args '("--login" "-i"))
         (setenv "SHELL" shell-file-name)
         (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)))
#+END_SRC
* TERMINAL - ansi-term improvements
#+BEGIN_SRC emacs-lisp
(defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
  "Close an ansi-term buffer if I quit the terminal."
  (if (memq (process-status proc) '(signal exit))
      (let ((buffer (process-buffer proc)))
        ad-do-it
        (kill-buffer buffer))
    ad-do-it))
(ad-activate 'term-sentinel)

;; Use UTF8 in terminals
(add-hook 'term-exec-hook
          '(lambda () (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix)))

;; Make URLs in the term clickable
(defun my-term-paste (&optional string)
  (interactive)
  (process-send-string
   (get-buffer-process (current-buffer))
   (if string string (current-kill 0))))
(add-hook 'term-mode-hook
          '(lambda ()
             (goto-address-mode)
             (define-key term-raw-map (kbd "C-y") 'my-term-paste)))
#+END_SRC

* COMPLETION
Company will *COMP*lete *ANY*thing.

#+BEGIN_SRC emacs-lisp
(use-package company :ensure t :diminish
  :bind (("TAB" . company-indent-or-complete-common)
         ("M-4" . company-ispell)
         :map company-active-map)
  :config
  (setq company-tooltip-align-annotations t
        company-idle-delay nil
        company-minimum-prefix-length 3
        company-backends (list 'company-files
                               'company-anaconda
                               ;; 'company-racer
                               'company-clang
                               'company-yasnippet
                               'company-dabbrev-code
                               'company-dabbrev)))
(add-hook 'after-init-hook 'global-company-mode)
(use-package company-try-hard :ensure t
  :bind(("C-z" . company-try-hard)
        :map company-active-map))
(use-package company-bibtex :ensure t)
(use-package company-quickhelp :ensure t
  :config (company-quickhelp-mode))

(use-package company-racer :ensure t)

(defvar my/company-point nil)
(advice-add 'company-complete-common :before
            (lambda () (setq my/company-point (point))))
(advice-add 'company-complete-common :after
            (lambda ()
              (when (equal my/company-point (point))
                (yas-expand))))

(add-hook 'org-mode-hook '(lambda () (add-to-list 'company-backends 'company-ispell)))
#+END_SRC
* LINTING
Flycheck basically runs linters and stuff, and lets you know problems in your code in ~realtime.
#+BEGIN_SRC emacs-lisp
(use-package flycheck :ensure t
  :hook (after-init . global-flycheck-mode)
  :config
  (setq-default
   flycheck-disabled-checkers
   (append flycheck-disabled-checkers '(javascript-jshint) '(json-jsonlist))
   flycheck-temp-prefix ".flycheck")
  (flycheck-add-mode 'javascript-eslint 'web-mode))
#+END_SRC

* PROGRAMMING LANGUAGES
** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode :ensure t
  :hook (markdown-mode . visual-line-mode)
  :config
  (add-to-list 'auto-mode-alist
               (cons "\\.\\(md\\|markdown\\)\\'" 'markdown-mode))
  (add-to-list 'auto-mode-alist '("\\.txt$" . markdown-mode)))
#+END_SRC
** Go
#+BEGIN_SRC emacs-lisp
(use-package go-mode :ensure t
  :hook (before-save . gofmt-before-save)
  :config (setq gofmt-command "goimports"))
#+END_SRC
** Rust
Auto-completion for rust, using racer
#+BEGIN_SRC emacs-lisp
(use-package rust-mode :ensure t
  :hook (rust-mode . company-mode))
(use-package flymake-rust :ensure t)
(use-package flycheck-rust :ensure t)
(use-package cargo :ensure t
  :hook (rust-mode . cargo-minor-mode))
(use-package racer :ensure t
  :hook ((racer-mode . company-mode)
         (racer-mode . eldoc-mode)
         (rust-mode . racer-mode)))
(add-hook 'rust-mode-hook '(lambda () (add-to-list 'company-backends 'company-racer)))
#+END_SRC
** Python
#+BEGIN_SRC emacs-lisp
(use-package pyvenv :ensure t)
(use-package anaconda-mode :ensure t
  :config
  (add-to-list 'python-shell-completion-native-disabled-interpreters "jupyter")
  :hook (python-mode . anaconda-mode))

(use-package company-anaconda :ensure t)
(eval-after-load "company" '(add-to-list 'company-backends 'company-anaconda))
(setq python-indent-offset 4
      python-shell-virtualenv-root "~/.envs/ml/"
      python-shell-interpreter "jupyter"
      python-shell-interpreter-args "console --simple-prompt")

(defun ipython()
  (interactive)
  (if (and is-windows? (not (s-matches? "Linux" (shell-command-to-string "uname -a"))))
      (progn (setq explicit-shell-file-name
                   "C:/python3/scripts/ipython.exe")
             (setq shell-file-name "ipython")
             (setq explicit-sh.exe-args '("--login" "-i"))
             (setenv "SHELL" shell-file-name)
             (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)
             (shell)
             (cd/set-windows-shell))
    (ansi-term "~/.envs/ml/bin/ipython" "ipython")))

(if is-windows?
    (when (boundp 'python-shell-exec-path)
      (add-to-list 'python-shell-exec-path "c:/ProgramData/Miniconda3/"))
  (when (boundp 'python-shell-exec-path)
    (add-to-list 'python-shell-exec-path "~/.envs/ml/bin/")))
#+END_SRC
** Javascript & SASS
#+BEGIN_SRC emacs-lisp
(use-package sass-mode :ensure t)
(use-package js2-mode :ensure t)
#+END_SRC
** TODO Latex
#+BEGIN_SRC emacs-lisp :tangle no
(use-package tex :ensure auctex
  :config
  (setq TeX-auto-save t
        TeX-parse-self t
        TeX-save-query nil
        ispell-program-name "aspell"
        ispell-dictionary "english")
  :hook ((LaTeX-mode . flyspell-mode)
         (LaTeX-mode . flyspell-buffer)
         (LaTeX-mode . outline-minor-mode)
         (LaTeX-mode . visual-line-mode)
         (LaTeX-mode . turn-on-reftex)))

;; Manage citations
;; (require 'tex-site)
;; (autoload 'reftex-mode "reftex" "RefTeX Minor Mode" t)
;; (autoload 'turn-on-reftex "reftex" "RefTeX Minor Mode" nil)
;; (autoload 'reftex-citation "reftex-cite" "Make citation" nil)
;; (autoload 'reftex-index-phrase-mode "reftex-index" "Phrase Mode" t)

;; (setq LaTeX-eqnarray-label "eq"
;;       LaTeX-equation-label "eq"
;;       LaTeX-figure-label "fig"
;;       LaTeX-table-label "tab"
;;       LaTeX-myChapter-label "chap"
;;       TeX-auto-save t
;;       TeX-newline-function 'reindent-then-newline-and-indent
;;       TeX-parse-self t
;;       TeX-style-path '("style/" "auto/"
;;                        "/usr/share/emacs21/site-lisp/auctex/style/"
;;                        "/var/lib/auctex/emacs21/"
;;                        "/usr/local/share/emacs/site-lisp/auctex/style/")
;;       LaTeX-section-hook '(LaTeX-section-heading
;;                            LaTeX-section-title
;;                            LaTeX-section-toc
;;                            LaTeX-section-section
;;                            LaTeX-section-label))
#+END_SRC
** TODO Elixir
#+begin_src emacs-lisp :tangle no
(use-package alchemist :ensure t)
#+end_src
** TODO Julia
#+BEGIN_SRC emacs-lisp :tangle no
(use-package julia-mode :ensure t)
(use-package julia-repl :ensure t
  :config
  (add-hook 'julia-mode-hook 'julia-repl-mode))

(add-to-list 'load-path "C:/Julia-1.1.0/bin")
(if is-windows?
    (setq julia-repl-executable-records '((default "julia.exe" :basedir "C:/Julia-1.1.0/bin" ))))

;; (setq julia-repl-executable-records '((default "julia")))
#+END_SRC
** TODO LISP -- Clojure and Cider
#+BEGIN_SRC emacs-lisp :tangle no
;; Cider for interactive clojure programming
(use-package paredit-mode :ensure t)
(use-package parinfer
  :ensure t
  :hook ((clojure-mode . parinfer-mode)
         (emacs-lisp-mode . parinfer-mode)
         (common-lisp-mode . parinfer-mode)
         (scheme-mode-hook . parinfer-mode)
         (lisp-mode . parinfer-mode))
  :bind
  (("C-," . parinfer-toggle-mode))
  :config
  (setq parinfer-extensions
        '(defaults       ; should be included.
           pretty-parens  ; different paren styles for different modes.
           evil           ; If you use Evil.
           lispy          ; If you use Lispy. With this extension, you should install Lispy and do not enable lispy-mode directly.
           paredit        ; Introduce some paredit commands.
           smart-tab      ; C-b & C-f jump positions and smart shift with tab & S-tab.
           smart-yank)))   ; Yank behavior depend on mode.
(use-package flycheck-clojure :ensure t)
(use-package smartparens :ensure t)
(use-package cider :ensure t
  :hook ((cider-mode . eldoc-mode)
         (cider-repl-mode . subword-mode)
         (cider-repl-mode . smartparens-mode)
         (cider-repl-mode . paredit-mode))
  :config
  (setq nrepl-popup-stacktraces nil)
  (with-eval-after-load 'clojure-mode
    (with-eval-after-load 'flycheck
      (flycheck-clojure-setup))))
#+END_SRC

* NAVIGATION (windows, menus, buffers)
** Ivy (counsel, swiper, ivy) for navigation most menu-type things
Navigation of pretty much any /menu-type/ thing.

- =Ivy= and =counsel= make things like ~M-x~ and grep easier.
- =swiper= is a popup search of the current buffer.
- =imenu-anywhere= will search for headings/functions recursively over all files of the same /mode/

#+BEGIN_SRC emacs-lisp
(use-package counsel
  :after ivy
  :bind* (("C-x f" . counsel-find-file)
          ("C-c i" . counsel-imenu)
          ("C-c a" . counsel-rg)
          ("C-c g s" . counsel-grep-or-swiper)
          ("C-c b" . counsel-descbinds)
          ("M-x" . counsel-M-x))
  :config
  (setq counsel-grep-base-command
		"rg -i -M 120 --no-heading --line-number --color never '%s' %s"))

(use-package ivy :ensure t :diminish
  :bind (("C-x b" . ivy-switch-buffer)
		 ("C-c s" . swiper))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t
		ivy-count-format ""
		;; ivy-initial-inputs-alist nil
		ivy-re-builders-alist '((counsel-file-jump . ivy--regex-fuzzy)
                                (find-file . ivy--regex-fuzzy)
                                (t . ivy--regex-plus))))

(use-package swiper :ensure t)
(use-package imenu-anywhere :ensure t)

(use-package dumb-jump :ensure t
  :hook (prog-mode . dumb-jump-mode)
  :config
  (setq dumb-jump-selector 'ivy)
  (setq dumb-jump-prefer-searcher 'rg))

(use-package avy :ensure t)
(global-set-key (kbd "C-:") 'avy-goto-char-2)
  #+END_SRC
** Switch between windows
Give HUD prompt when changing window, and keybind to cycle through windows.

#+BEGIN_SRC emacs-lisp
;; Prompt with a hud when switching windows, if more than 2 windows
(use-package switch-window
  :ensure t
  :bind ("C-x o" . switch-window))

;; cycle through 'windows' (e.g. panes)
(define-key global-map (kbd "M-`") 'next-multiframe-window)
(define-key global-map (kbd "C-M-`") 'previous-multiframe-window)
#+END_SRC

** ibuffer - view all open buffers
#+BEGIN_SRC emacs-lisp
;; Interactively modify buffer list
(use-package fullframe :ensure t)
(with-eval-after-load 'buffer (fullframe ibuffer ibuffer-quit))

(with-eval-after-load 'ibuffer
  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     (t (format "%8d" (buffer-size))))))

(global-set-key (kbd "C-x C-b") 'ibuffer)

(setq ibuffer-saved-filter-groups
      '(("home"
         ("Code" (filename . "code/"))
         ("Notes" (and
                   (mode . org-mode)
                   (filename . "Dropbox/notes/")))
         )))
(add-hook 'ibuffer-mode-hook '(lambda () (ibuffer-switch-to-saved-filter-groups "home")))
#+END_SRC

* Org-mode
Org-mode is a really powerful notetaking tool.

You can easily /capture/ information using various different templates (including custom templates), and then refile them to perhaps a more appropriate location,

/Agenda/ lets you schedule and deadline tasks.
** General Org Config

#+BEGIN_SRC emacs-lisp
(defun cd/org-open-link-same ()
  (interactive)
  (let ((old-setup org-link-frame-setup))
    (setq org-link-frame-setup '((file . find-file)))
    (org-open-at-point)
    (setq org-link-frame-setup old-setup)))

(load-library "find-lisp")
(use-package org
  :ensure t
  :hook ((org-mode . visual-line-mode)
         (org-mode . org-indent-mode)
         (org-mode . abbrev-mode)
         (org-mode . (lambda () (set-face-italic 'italic t))))
  :config
  (setq org-directory "~/Dropbox/notes"
        org-default-notes-file "~/Dropbox/notes/inbox.org"
        org-src-window-setup 'current-window
        org-agenda-window-setup 'only-window
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-confirm-babel-evaluate nil
        org-pretty-entities t
        org-edit-src-content-indentation 0
        org-list-description-max-indent 5
        org-catch-invisible-edits 'show-and-error
        org-fontify-done-headline t
        org-insert-heading-respect-content t
        org-imenu-depth 4
        ;; Use M-+ M-- to change todo, and leave S-<arrow> for windows
        org-replace-disputed-keys t
        org-blank-before-new-entry '((heading . nil) (plain-list-item . auto))
        inhibit-compacting-font-caches t
        org-hide-emphasis-markers t
        org-todo-keywords'((sequence "TODO" "WIP" "|" "DONE")
                           (sequence "|" "DEAD"))
        org-agenda-skip-scheduled-if-done nil
        org-agenda-start-with-log-mode t
        org-agenda-skip-deadline-prewarning-if-scheduled t
        org-startup-indented t
        org-hide-leading-stars t
        org-cycle-separator-lines 0
        org-list-indent-offset 2
        org-modules '(org-bibtex org-habit org-tempo)
        org-agenda-files '("~/Dropbox/notes/")
        org-agenda-use-time-grid nil
        org-agenda-time-grid '((daily today require-timed) (900 1300 1700 2100) "  --- " "")
        org-agenda-confirm-kill nil
        org-log-done nil
        org-log-repeat nil
        org-log-into-drawer nil
        org-log-done-with-time nil
        org-hierarchical-todo-statistics t
        org-ellipsis "…"
        org-archive-location "~/Dropbox/notes/archive.org::"
        org-confirm-babel-evaluate nil
        ;; Settings for refiling
        org-reverse-note-order t
        org-refile-use-outline-path t
        org-yank-adjusted-subtrees nil
        org-outline-path-complete-in-steps nil
        org-refile-allow-creating-parent-nodes 'confirm
        org-refile-use-cache nil
        org-refile-targets '((org-agenda-files . (:maxlevel . 3))))
  ;; Allow 2 newlines inside an org-mode 'emphasis' (e.g. bold or italic)
  (setcar (nthcdr 4 org-emphasis-regexp-components) 2)
  (org-babel-do-load-languages
   'org-babel-load-languages '((python . t)
                               (sqlite . t)
                               (emacs-lisp . t)))
  (set-face-attribute 'org-block-begin-line nil :height 0.7 :slant 'normal))

;; Need ~htmlize~ so that I can export org buffers to HTML.
(use-package htmlize :ensure t)
(diminish 'abbrev-mode)
(diminish 'org-indent-mode)

(define-key org-mode-map (kbd "C-c ,") 'org-time-stamp-inactive)
(global-set-key (kbd "<f1>")
                (lambda () (interactive)
                  (refresh-capture-templates)
                  (org-capture)))
(global-set-key (kbd "<f2>") 'org-agenda)
(global-set-key (kbd "<f4>")
                (lambda () (interactive)
                  (refresh-capture-templates)
                  (org-capture nil "nn")))
(global-set-key (kbd "<f9>")
                (lambda () (interactive)
                  (refresh-capture-templates)
                  (org-capture nil "L")))
(global-set-key (kbd "C-c l") 'org-store-link)
(global-set-key (kbd "C-c o") 'cd/org-open-link-same)
#+END_SRC

** Fix indentation for org source blocks
#+BEGIN_SRC emacs-lisp
(defun cd/org-cleanup ()
  (interactive)
  (org-edit-special)
  (indent-region (point-min) (point-max))
  (org-edit-src-exit))
(global-set-key (kbd "C-x c") 'cd/org-cleanup)
#+END_SRC
** defun: Move to prev/next narrow
#+BEGIN_SRC emacs-lisp
(defun cd/move-to-previous-narrow ()
  (interactive)
  (progn
    (beginning-of-buffer)
    (widen)
    (outline-previous-heading)
    (org-narrow-to-subtree)))

(defun cd/move-to-next-narrow ()
  (interactive)
  (progn
    (beginning-of-buffer)
    (widen)
    (outline-next-heading)
    (org-narrow-to-subtree)))
#+END_SRC
** Capture templates
Split the org-capture-template into multiple source blocks and functions so that when I use 'helper' functions, they are defined alongside the relevant capture template.
#+BEGIN_SRC emacs-lisp
(defun refresh-capture-templates ()
  (interactive)
  (setq org-capture-templates
        (append (cd/capture-template-notes)
                (cd/capture-template-todos)
                (cd/capture-template-logbooks)
                (cd/capture-template-watch)
                (cd/capture-template-gaming)
                (cd/capture-template-emacsconfig)
                (cd/capture-template-calendar)
                (cd/capture-template-quote)
                (cd/capture-template-literature))))
#+END_SRC

*** Simple 'todo' captures
#+BEGIN_SRC emacs-lisp
(defun cd/capture-template-todos ()
  `(("t" "Todos" entry (file+headline "todo.org" "REFILE") "** TODO %?")
    ("r" "Research" entry (file+headline "todo.org" "REFILE") "** TODO Research %?")
    ("$" "Shopping" entry (file+headline "want.org" "General") "** %?")))
#+END_SRC

*** 'notes'
#+begin_src emacs-lisp
(defun cd/capture-template-notes ()
  `(("n" "Note")
    ("nn" "List item" item (file+headline "inbox.org" "Notes")
     "- %?")
    ("nl" "List link" item (file+headline "inbox.org" "Notes")
     "- [[%^{URL}][%^{Description}]] %?")
    ("nN" "Entry" entry (file "inbox.org") "* %?")))
#+end_src

*** logbook
#+begin_src emacs-lisp
(defun cd/capture-template-logbooks ()
  `(("l" "Logbook")
    ("ll" "Logbook item" item (file+datetree "logbook.org")
     "- %?")
    ("lL" "Logbook entry" entry (file+datetree "logbook.org")
     "* %?")))
#+end_src
*** gaming
#+begin_src emacs-lisp
(defun cd/capture-template-gaming ()
  `(("g" "Games")
    ("gp" "PC" entry (file+olp "pc-games.org" "Future / Unreleased" "gaming.org" "PC")
     "* %^{Todo|TODO|WAIT|BUY|NEXT|PLAYING|DONE} %^{PC game}\n:%?")
    ("gn" "Nintendo Switch" entry (file+olp "nintendo-switch-games.org" "Future / Unreleased")
     "* %^{Todo|TODO|WAIT|BUY|NEXT|PLAYING|DONE} %^{Nintendo Switch game}\n:%?\n")
    ("gt" "Tabletop" entry (file+headline "tabletop-games.org" "Potential Purchases")
     "* %^{Todo|TODO|BUY} %^{Tabletop game}\n%?\n")))
#+end_src
*** stuff to watch
#+begin_src emacs-lisp
(defun cd/capture-template-watch ()
  `(("w" "Watch")
    ("wt" "TV" item
     (file+olp "tv-shows-and-films.org" "TV Shows / Series" "To Watch")
     "%^{TV}" :immediate-finish t)
    ("wf" "film" item
     (file+olp "tv-shows-and-films.org" "Films" "To Watch")
     "%^{Film}" :immediate-finish t)))
#+end_src
*** stuff to read (books and literature)
These are helpers to make entering a literature entry easier.
#+BEGIN_SRC emacs-lisp
(defun read-capitalized-title ()
  (s-titleize (read-string "Title: ")))

(defun read-author ()
  (let ((name (read-string "Author: " "" nil nil)))
    (if (s-equals? name "")
        nil
      (format-author-name name))))

(defun format-author-name (author)
  (concat (seq-mapcat
           (lambda (author-part)
             (if (> (length author-part) 1)
                 (s-concat " " (s-capitalize author-part))
               (s-concat (s-capitalize author-part) ".")))
           (s-split " " author))))

(defun maybe-get-bibtex ()
  (let ((doi (read-string "DOI: " "" nil nil)))
    (if (s-equals? doi "")
        nil
      (s-concat ("\n")))))

(defun read-authors ()
  (setq authors (read-author)
        running t)
  (while running
    (setq input (read-author))
    (if (s-equals? input nil)
        (setq running nil)
      (setq authors (concat authors " and " input))))
  authors)

(defun cd/capture-template-literature ()
  `(("L" "Literature" entry (file+headline "literature.org" "REFILE")
     "** TODO %(read-capitalized-title)\n\nAuthors: %(read-authors)\n\n#+BEGIN_SRC bibtex\n%(doi-insert-bibtex)\n#+END_SRC" :immediate-finish t)

    ("b" "book" entry (file+olp "books.org" "Book List" "Refile")
     "** TO-READ %^{Book}\n%^{AUTHOR}p")))
#+end_src
*** emacs config testing
#+begin_src emacs-lisp
(defun cd/capture-template-emacsconfig ()
  `(("e" "emacs config" plain (file+headline "~/.emacs.d/chris-davison.org" "Testing Ground")
     "%?\n\n#+BEGIN_SRC emacs-lisp\n\n#+END_SRC" :empty-lines 1)))
#+end_src
*** calendar entry
#+begin_src emacs-lisp
(defun cd/capture-template-calendar ()
  `(("c" "Calendar" entry (file+olp+datetree "calendar.org")
     "* TODO %?\nDEADLINE: %t" :time-prompt t)))
#+end_src
*** quote entry
#+begin_src emacs-lisp
(defun cd/capture-template-quote ()
  `(("Q" "Quote" entry (file "quotes.org")
     "* %^{Quote Topic}\n#+BEGIN_QUOTE\n%^{Quote} (%^{Author})\n#+END_QUOTE")))
#+end_src
** defun: Update checkboxes on save
On saving org files, update checkbox counts in all headers. This will only work if the buffer is actually modified, otherwise you get a 'nothing to save' message and the hook doesn't run. This shouldn't really be an issue unless I've somehow managed to modify the buffer and save it without this hook running (maybe using orgly for example).
#+BEGIN_SRC emacs-lisp :tangle no
(defun custom_org_auto_check()
  (interactive)
  (org-update-checkbox-count t))

(add-hook 'org-mode-hook
          (lambda ()(add-hook 'before-save-hook 'custom_org_auto_check)))
#+END_SRC
** Agenda view WITHOUT archived
#+BEGIN_SRC emacs-lisp
(setq org-agenda-custom-commands
      '(
        ("1" "Today, no upcoming deadlines"
         ((agenda "" ((org-agenda-span 1)
                      (org-agenda-use-time-grid t)
                      (org-deadline-warning-days 0)))))
        ("7" "Week, no upcoming deadlines"
         ((agenda "" ((org-agenda-span 7)
                      (org-deadline-warning-days 0)))))

        ;; ("w" . "Work Schedules")
        ;; ("ww" "Work and Thesis"
        ;;  ((todo "TODO|WIP" ((org-agenda-files '("~/Dropbox/notes/work.org" "~/Dropbox/notes/thesis.org"))))))
        ;; ("wu" "Unscheduled Work and Thesis"
        ;;  ((todo ""
        ;;         ((org-agenda-overriding-header "\nUnscheduled Work and Thesis")
        ;;          (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
        ;;          (org-agenda-files
        ;;           '("~/Dropbox/notes/work.org" "~/Dropbox/notes/thesis.org"))))
        ;;   nil
        ;;   nil))

        ;; ("ngt" "Non-gaming Todos"
        ;;  ((todo "TODO|WIP" ((org-agenda-overriding-header "Non-gaming Todos")
        ;;                     (org-agenda-files
        ;;                      (seq-filter
        ;;                       (lambda (x) (not (string-match "gaming" x)))
        ;;                       (file-expand-wildcards "~/Dropbox/notes/*.org"))
        ;;                      )))))
        ))

(global-set-key
 (kbd "<f3>")
 '(lambda () (interactive) (org-agenda nil "7")))
#+END_SRC
** drag-and-drop of files into org-files
This package lets you drag and drop stuff into org-mode files, copying (or downloading, if a web resource) into the relevant directory.

In this case, I've set it up to copy to a local 'assets' folder.  If ~org-download-heading-lvl~ is non-nil, it would create a subfolder based on the Nth heading.
#+BEGIN_SRC emacs-lisp
(use-package org-download :ensure t
  :config
  (setq-default org-download-image-dir "./assets")
  (setq-default org-download-heading-lvl nil))
(add-hook 'dired-mode-hook 'org-download-enable)
#+END_SRC
** Refile
*** ..to a specific file

This is a general helper function that will refile the subtree at point to a specific file.  I use this along with hydra to let me refile to a few default locations. If called from a script (e.g. ~(refile-to-file "~/Dropbox/work.org")~, it'll set work to be the /only/ refile target. Otherwise, it'll prompt for a file (using a proper file dialog), and then only refile within that file.

#+BEGIN_SRC emacs-lisp
(defun my/refile (file headline &optional arg)
  (let ((pos (save-excursion
               (find-file file)
               (org-find-exact-headline-in-buffer headline))))
    (org-refile arg nil (list headline file nil pos)))
  (switch-to-buffer (current-buffer)))

(defun refile-to-file (&optional target)
  (interactive)
  (let ((filename (or target (read-file-name "Refile to: ")))
        (old-refile-targets org-refile-targets))
    (progn (setq org-refile-targets `((filename . (:maxlevel . 6))))
           (org-refile)
           (setq org-refile-targets old-refile-targets))))

(defun refile-to-this-file ()
  (interactive)
  (refile-to-file (buffer-name)))
#+END_SRC
*** ..to subtree of a new file (with file prompt)
#+BEGIN_SRC emacs-lisp
(require 'org-element)

(defun org-file-from-subtree (&optional name)
  "Cut the subtree currently being edited and create a new file
from it.

If called with the universal argument, prompt for new filename,
otherwise use the subtree title"
  (interactive "P")
  (let ((filename (expand-file-name (read-file-name "New file name:"))))
    (org-cut-subtree)
    (find-file-noselect filename)
    (with-temp-file filename
      (org-mode)
      (yank))
    (find-file filename)))
(define-key org-mode-map (kbd "C-x C-n") 'org-file-from-subtree)
#+END_SRC

** Insert an indented header
#+BEGIN_SRC emacs-lisp
(defun org-insert-indented-header ()
  (interactive)
  (org-insert-heading-respect-content)
  (org-do-demote))
(define-key org-mode-map (kbd "C-M-<return>") 'org-insert-indented-header)
#+END_SRC
** Mark a tree as DONE if it's TODO and all children are DONE
If a tree has a todo state and TODO children, then mark it as done when all children are done.
#+BEGIN_SRC emacs-lisp
(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done."
  (let (org-log-done org-log-states) ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" (if (> n-done 0) "WIP" "TODO")))))
(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+END_SRC
** Recurring tasks
#+BEGIN_SRC emacs-lisp
(use-package org-recur
  :hook ((org-mode . org-recur-mode)
         (org-agenda-mode . org-recur-agenda-mode))
  :demand t
  :config
  (define-key org-recur-mode-map (kbd "C-c d") 'org-recur-finish)

  ;; Rebind the 'd' key in org-agenda (default: `org-agenda-day-view').
  (define-key org-recur-agenda-mode-map (kbd "d") 'org-recur-finish)
  (define-key org-recur-agenda-mode-map (kbd "C-c d") 'org-recur-finish)

  (setq org-recur-finish-done t
        org-recur-finish-archive t))
#+END_SRC
** Org references
#+BEGIN_SRC emacs-lisp
(use-package org-ref :ensure t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(add-to-list 'auto-mode-alist '("\\.org_archive\\'" . org-mode))
#+END_SRC
** Checkboxes
*** defun: occur - highlight checkboxes
Simple function shortcuts to do an org-occur, or normal occur, for unticked checkboxes
#+BEGIN_SRC emacs-lisp
(defun checkboxes ()
  (interactive)
  (org-occur "\\[ \\]"))
(defun occur-checkboxes ()
  (interactive)
  (occur "\\[ \\]"))
#+END_SRC

*** defun: Sort checkboxes to top of list
Shortcut function to move all checked checkboxes to the top of the list
#+BEGIN_SRC emacs-lisp
(defun sort-checkboxes ()
  (interactive)
  (org-sort-list nil ?X))
#+END_SRC
*** defun: Reset recurring todo's checkboxes
Reset all checkboxes in a repeating todo when the state change is toggled through ~DONE~
#+BEGIN_SRC emacs-lisp
(defun glasser-org-reset-check-on-repeat ()
  (when (and (org-get-repeat) (member org-state org-done-keywords))
    (org-reset-checkbox-state-subtree)))
(add-hook 'org-after-todo-state-change-hook 'glasser-org-reset-check-on-repeat)
#+END_SRC


** Count subtree words
#+BEGIN_SRC emacs-lisp
(defun org-subtree-count-words ()
  (interactive)
  (progn
    (org-mark-subtree)
    (count-words-region (region-beginning) (region-end))))
#+END_SRC
** Archive all done tasks in file
#+begin_src emacs-lisp
(defun cd/org-archive-all-done-tasks ()
  (interactive)
  (org-map-entries 'org-archive-subtree "/DONE" 'file))
#+end_src
* Hydra -- General utility HUDs
#+BEGIN_SRC emacs-lisp
(use-package hydra :ensure t)
(defhydra hydra/main (:hint nil :exit t)
  ("w" hydra-window/body "+WINDOW")
  ("o" hydra/org/body "+ORG")
  ("g" hydra/gist/body "+GIST")
  ("e" hydra/edit/body "+EDIT")
  ("b" hydra/bookmarks/body "+BOOKMARKS")
  ("j" hydra/indent-or-join-lines/body "+INDENT OR JOIN")
  ("n" hydra/navigation-and-search/body "+NAV")
  ("C-z" company-try-hard "complete")
  ("t" (term "/usr/bin/zsh") "terminal")
  ("q" nil nil))
(define-key global-map (kbd "C-z") 'hydra/main/body)

#+END_SRC
** Navigation and search
#+begin_src emacs-lisp
(defhydra hydra/navigation-and-search (:hint nil :exit t)
  "NAVIGATE"
  ("c" avy-goto-char-2 "char")
  ("l" avy-goto-line "line")
  ("w" avy-goto-word-0 "word")
  ("s" counsel-grep-or-swiper "swiper")
  ("g" deadgrep "grep")
  ("i" ivy-imenu-anywhere "imenu")
  ("b" hydra-breadcrumb/body "+BREADCRUMBS")
  ("n" notes "notes")
  ("q" nil nil))
#+end_src

** Bookmarks / common files
#+begin_src emacs-lisp
(defhydra hydra/bookmarks (:hint nil :exit t)
  "Bookmarks"
  ("e" (find-file "~/.emacs.d/chris-davison.org") "emacs config")
  ("c" (find-file "~/Dropbox/notes/calendar.org") "calendar")
  ("t" (find-file "~/Dropbox/notes/todo.org") "todos")
  ("l" (find-file "~/Dropbox/notes/logbook.org") "logbook")
  ("i" (find-file "~/Dropbox/notes/inbox.org") "inbox")
  ("q" nil nil))
#+end_src
** Windows / splits
#+begin_src emacs-lisp
(defhydra hydra-window (:hint nil :exit t)
  "
_h_ ←  _j_ ↓  _k_ ↑  _l_ →
split _r_ight _d_own _c_hoose
_z_oom (focus one window)
_D_elete
"
  ("h" windmove-left )
  ("j" windmove-down )
  ("k" windmove-up )
  ("l" windmove-right )
  ("c" (lambda ()
         (interactive)
         (switch-window)
         (add-hook 'aceq-window-end-once-hook
                   'hydra-window/body)))
  ("r" (lambda () (interactive) (split-window-right) (windmove-right)))
  ("d" (lambda () (interactive) (split-window-below) (windmove-down)))
  ("D" delete-window)
  ("z" modi/toggle-one-window)
  ("q" nil))
(global-set-key (kbd "C-S-w") 'hydra-window/body)
#+end_src
** Breadcrumbs (like vim C-o C-i)
#+begin_src emacs-lisp
(defhydra hydra-breadcrumb
  (:exit t)
  "
  Breadcrumb bookmarks:
  _<up>_:   prev   _S-<up>_:   local prev
  _<down>_: next   _S-<down>_: local next
  _s_: set  _c_: clear  _l_: list  _q_: quit
  "
  ("<down>" bc-next nil :exit nil)
  ("<up>" bc-previous nil :exit nil)
  ("S-<down>" bc-local-next nil :exit nil)
  ("S-<up>" bc-local-previous nil :exit nil)
  ("l" bc-list nil)
  ("s" bc-set nil)
  ("c" bc-clear nil)
  ("q" nil nil))
#+end_src
** Github Gists
#+begin_src emacs-lisp
(defhydra hydra/gist (:hint nil)
  "Gist"
  ("b" gist-buffer "buffer")
  ("p" gist-buffer-private "private buffer")
  ("r" gist-region "region")
  ("f" gist-fetch "fetch")
  ("l" gist-list "list")
  ("q" nil nil))
#+end_src
** Org-mode
#+begin_src emacs-lisp
(defhydra hydra/org (:hint nil :exit t)
  "Org-Mode"
  ("o" cd/org-open-link-same "open link")
  ("C-o" org-mark-ring-goto "return from link")
  ("r" org-refile "refile")
  ("t" refile-to-this-file "refile here")
  ("a" cd/org-archive-all-done-tasks "archive all done")
  ("j" org-refile-goto-last-stored "goto last refile")
  ("c" org-capture-goto-last-stored "goto last capture")
  ("n" cd/move-to-next-narrow "next narrow" :exit nil)
  ("p" cd/move-to-previous-narrow "prev narrow" :exit nil)
  ("w" (my/refile "~/Dropbox/notes/todo.org" "work") "refile work")
  ("C-r" helm-org-rifle "rifle")
  ("q" nil nil))
(define-key org-mode-map (kbd "C-c C-w") 'hydra/org/body)
#+end_src


* Appearance
** Fonts
List some pretty fonts, and grab the first one that's available.
#+BEGIN_SRC emacs-lisp
(setq cd-fonts
      (cl-remove-if (lambda (font) (not (member font (font-family-list))))
                    '("Inconsolata" "JetBrains Mono" "Source Code Pro" "Cascadia Code" "Fantasque Sans Mono" "CamingoCode" "Roboto Mono" "Ubuntu Mono" "Liberation Mono" "Fira Code")))
(when cd-fonts
  (let ((first (car cd-fonts)))
    (set-frame-font first 1)
    first))

(defun set-pretty-font ()
  "Set a font from one of the available fonts that I like"
  (interactive)
  (set-frame-font (ivy-read "Pick font:" cd-fonts) 1))

(defvar current-font-idx 0)
(defun next-font ()
  (interactive)
  (setq current-font-idx
        (% (+ 1 current-font-idx)
           (length cd-fonts)))
  (let ((next-font-name (nth current-font-idx cd-fonts)))
    (set-frame-font next-font-name 1)
    (message next-font-name)))
(if is-windows?
    (set-frame-font "CamingoCode" 1)
  (next-font))
(global-set-key (kbd "C-c f") 'next-font)

(setq line-spacing nil)
(set-face-attribute 'default nil :height (if is-windows? 145 150))
(setq auto-window-vscroll nil)
#+END_SRC

** Colour themes

Disable themes before loading a new theme.  This can cause some issues when using things like 'powerline', as powerline is technically a theme.  Because smart-mode-line was later in my emacs config, my actual colour theme ended up getting disabled.  Disabling this for now until I decide if I really need it.
#+BEGIN_SRC emacs-lisp
(defadvice load-theme (before theme-dont-propagate activate)
  (disable-all-themes))

(defadvice load-theme (after run-after-load-theme-hook activate)
  (set-face-italic 'italic t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun disable-all-themes ()
  (interactive)
  (mapc 'disable-theme custom-enabled-themes))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq custom-safe-themes t)    ;; themes are 'safe'
(use-package doneburn-theme)
(use-package darkokai-theme)
(use-package doom-themes)
(use-package cyberpunk-theme)
(use-package cyberpunk-2019-theme)
(use-package doom-modeline :ensure t)

;; (load-theme 'doom-gruvbox t)
(doom-modeline-mode)
(load-theme 'doom-gruvbox t)
#+END_SRC

Utility function to loop through themes
#+BEGIN_SRC emacs-lisp
(defvar current-theme-idx 0)
(defun next-theme ()
  (interactive)
  (let* ((themes (custom-available-themes))
         (nthemes (length themes))
         (nnext (% (+ 1 current-theme-idx) nthemes))
         (tnext (nth nnext themes)))
    (setq current-theme-idx nnext)
    (load-theme tnext t)
    tnext))
(global-set-key (kbd "C-c t") '(lambda () (interactive) (message (symbol-name (next-theme)))))
#+END_SRC
** Temporary 'zoom' into a pane
A bit like 'focus mode' for other languages.  Can perhaps combine this with /darkroom/ to enforce distraction free writing.

From [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-windows-buffers.el][this github repo]].
#+BEGIN_SRC emacs-lisp
(defvar modi/toggle-one-window--buffer-name nil
  "Variable to store the name of the buffer for which the `modi/toggle-one-window'
function is called.")

(defvar modi/toggle-one-window--window-configuration nil
  "Variable to store the window configuration before `modi/toggle-one-window'
function was called.")

(defun modi/toggle-one-window (&optional force-one-window)
  "Toggles the frame state between deleting all windows other than
the current window and the windows state prior to that."
  (interactive "P")
  (if (or (null (one-window-p)) force-one-window)
      (progn
        (setq modi/toggle-one-window--buffer-name (buffer-name))
        (setq modi/toggle-one-window--window-configuration (current-window-configuration))
        (delete-other-windows))
    (progn
      (when modi/toggle-one-window--buffer-name
        (set-window-configuration modi/toggle-one-window--window-configuration)
        (switch-to-buffer modi/toggle-one-window--buffer-name)))))
(define-key global-map (kbd "C-x 1") 'modi/toggle-one-window)

#+END_SRC
** Code-folding
#+BEGIN_SRC emacs-lisp
;; Code folding
(use-package yafolding :ensure t)
(add-hook 'prog-mode-hook 'yafolding-mode)
(use-package fold-dwim :ensure t)
(use-package fold-dwim-org :ensure t)
(add-hook 'prog-mode-hook 'fold-dwim-org/minor-mode)
#+END_SRC
** General appearance configuration
Suppress GUI features
#+BEGIN_SRC emacs-lisp
(setq use-file-dialog nil
      use-dialog-box nil
      menu-bar-mode nil
      inhibit-startup-screen t
      inhibit-startup-echo-area-message t)
(add-hook 'after-init-hook '(lambda () (menu-bar-mode -1)))

;; Hide tool bar,  scroll bar and borders
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'set-scroll-bar-mode) (set-scroll-bar-mode nil))

(let ((no-border '(internal-border-width . 0)))
  (add-to-list 'default-frame-alist no-border)
  (add-to-list 'initial-frame-alist no-border))
#+END_SRC

Line highlighting, linum, colnum, and cursor
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
(blink-cursor-mode 0)
(setq linum-format "%d ")

;; Line number and column
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC

Tabstop stuff
#+BEGIN_SRC emacs-lisp
(setq tab-stop-list (number-sequence 4 200 4))
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+END_SRC

Don't scroll jump multiple lines
#+BEGIN_SRC emacs-lisp
(setq scroll-step 1
      scroll-conservatively 10000)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
(setq linum-format "%4d ")

(set-default 'indicate-empty-lines t)

;; Soft-wrap at a column.
;; Not currently setting this globally, as still unsure about
;; hard wrap vs soft-wrap vs soft-wrap with ruler
(use-package visual-fill-column :ensure t :diminish
  :config
  (setq visual-fill-column-width 80))

;; Replace lambda and AND etc with pretty symbols
(global-prettify-symbols-mode +1)
(diminish 'visual-line-mode)
#+END_SRC
* 'surrounds'
#+begin_src emacs-lisp
(use-package corral :ensure t)
(global-set-key (kbd "C-c c") #'hydra-corral/body)
#+end_src
* TODO EVIL - Vim emulation
EVIL mode?
#+BEGIN_SRC emacs-lisp :tangle no
(use-package evil :ensure t)
(use-package evil-commentary :ensure t)
(use-package evil-iedit-state :ensure t)
(use-package evil-org :ensure t)
#+END_SRC
* TODO DEFT - easily handle my notes dir
Deft - interactive filter on note contents (e.g. run =M-x deft= and then type in a query, and it'll narrow the files that match)
#+BEGIN_SRC emacs-lisp :tangle no
(use-package deft :ensure t
  :bind (("<f8>" . deft)
         ("<f7>" . deft-find-file))
  :config
  (setq deft-extension "org"
        deft-text-mode 'org-mode
        deft-directory "~/Dropbox/notes"
        deft-use-filename-as-title t
        deft-auto-save-interval 0
        deft-recursive t))
#+END_SRC


* helm rifle
#+BEGIN_SRC emacs-lisp
(use-package helm-org-rifle :ensure t
  :config
  (setq helm-org-rifle-show-path t))
#+END_SRC
* TESTING GROUND
Better 'help' buffers
#+BEGIN_SRC emacs-lisp
(use-package helpful :ensure t
  :config (setq helpful-max-buffers 2))
(global-set-key (kbd "C-h f") #'helpful-callable)
(global-set-key (kbd "C-h v") #'helpful-variable)
(global-set-key (kbd "C-h k") #'helpful-key)
#+END_SRC

A nice interface to ripgrep (choose specific filetypes, directory etc...and 'occur'-like buffer)
#+BEGIN_SRC emacs-lisp
(use-package deadgrep)
#+END_SRC

Rotate between 'common' layouts (e.g. vertical to horizontal split)
#+BEGIN_SRC emacs-lisp
(use-package rotate :ensure t
  :bind (("C-c r" . rotate-layout)))
#+END_SRC

When double clicking a file, or launching from terminal, always use the same instance of Emacs, rather than opening a new frame.
#+BEGIN_SRC emacs-lisp
(setq ns-pop-up-frames nil)
#+END_SRC

Set width of the window border
#+BEGIN_SRC emacs-lisp
(fringe-mode 10)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters :ensure t
  :hook ((prog-mode . rainbow-delimiters-mode)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package hide-lines :ensure t)
#+END_SRC

Read epub from within emacs
#+BEGIN_SRC emacs-lisp
(use-package nov :ensure t)
#+END_SRC

Switch to the new window when we create a split
#+BEGIN_SRC emacs-lisp
(global-set-key (kbd "C-x 2") (lambda () (interactive) (split-window-vertically) (other-window 1)))
(global-set-key (kbd "C-x 3") (lambda () (interactive) (split-window-horizontally) (other-window 1)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package lsp-mode :ensure t
  :config
  (add-hook 'c++-mode-hook #'lsp)
  (add-hook 'python-mode-hook #'lsp)
  (add-hook 'rust-mode-hook #'lsp))
#+END_SRC


Fix up titles from reading repes
#+BEGIN_SRC emacs-lisp :tangle no
(defun cd-fix-title ()
  "Fix a line like TODO this-was-a-filename into 'This Was A Filename'"
  (interactive)
  (kill-line)
  (insert (let* ((text (substring-no-properties (car kill-ring)))
                 (no-todo (replace-regexp-in-string "TODO " "" text))
                 (fixed (replace-regexp-in-string "-" " " no-todo)))
            (s-titleize fixed))))
#+END_SRC

Keybind to delete =CUSTOM_ID= property caused by pandoc conversion
#+BEGIN_SRC emacs-lisp :tangle no
(define-key org-mode-map
  (kbd "<f9>")
  '(lambda () (interactive)
     (org-delete-property-globally "CUSTOM_ID")
     (save-buffer-and-clear-modify)
     (kill-buffer)
     (deadgrep-forward-filename)
     (deadgrep-visit-result)))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package gist :ensure t
  :config
  (setq gist-ask-for-description t))
#+END_SRC

Cludge to make S-SPC not delete everything in ivy buffer (it's originally 'restrict to matches')
#+BEGIN_SRC emacs-lisp
(with-eval-after-load 'ivy-mode
  (define-key ivy-minibuffer-map (kbd "S-SPC") (insert " ")))
#+END_SRC

#+begin_src emacs-lisp
(use-package engine-mode :ensure t)
(defengine duckduckgo "https://duckduckgo.com/?q=%s" :keybinding "d")
(defengine github "https://github.com/search?ref=simplesearch&q=%s")
#+end_src

#+BEGIN_SRC emacs-lisp
(set-register ?t (cons 'file "~/Dropbox/notes/todo.org"))
(set-register ?i (cons 'file "~/Dropbox/notes/inbox.org"))
(set-register ?c (cons 'file "~/.emacs.d/chris-davison.org"))
#+END_SRC

#+BEGIN_SRC emacs-lisp :tangle no
(use-package projectile :ensure t
  :config (projectile-mode 1))
#+END_SRC

Sidebar for org mode
#+BEGIN_SRC emacs-lisp
(use-package org-sidebar :ensure t)
#+END_SRC


Filter sparse trees with a priority
#+BEGIN_SRC emacs-lisp :tangle no
(defun org-prioritised ()
  (interactive)
  (org-occur "\\[#" ))
#+END_SRC

Literate calc - realtime math evaluation. Use ~literate-calc-minor-mode~ in org-mode to get real-time math updates.
#+BEGIN_SRC emacs-lisp
(use-package literate-calc-mode :ensure t)
(use-package lively :ensure t)  ; remember this old package...
#+END_SRC

** Improve dired
#+BEGIN_SRC emacs-lisp
(defun mydired-sort ()
  "Sort dired listings with directories first."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(defadvice dired-readin
    (after dired-after-updating-hook first () activate)
  "Sort dired listings with directories first before adding marks."
  (mydired-sort))

(add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+END_SRC
** Popup keybind helper after delay
#+begin_src emacs-lisp
(use-package which-key :ensure t
  :config
  (setq which-key-idle-delay 1
        which-key-side-window-location 'bottom)
  (which-key-mode))
#+end_src
** Placeholders within buffers
#+begin_src emacs-lisp
(defun cd/placeholder (&optional text)
  (interactive)
  (cd/remove-placeholder)
  (insert (or text "<<placeholder>>")))

(defun cd/replace-placeholder (text)
  (interactive)
  (insert "<<placeholderplaceholder>>")
  (goto-line 1)
  (while (re-search-forward "<<placeholder>>" nil t)
    (replace-match ""))
  (goto-line 1)
  (re-search-forward "<<placeholderplaceholder>>" nil t)
  (replace-match text))

(defun cd/remove-placeholder ()
  (interactive)
  (cd/replace-placeholder ""))
#+end_src
