#+TITLE: Chris Davison's Emacs Config
#+PROPERTY: header-args emacs-lisp :tangle yes :results silent

* Configuration

You /tangle/ this file, using org-babel ~C-c C-v t~, which will create ~chris-davison.el~.  This file can either be loaded from an ~init.el~ (using ~(load "chris-davison.el" t)~), or by directly symlinking ~chris-davison.el~ to ~init.el~.  The symlinking may be a bit iffy on platforms like windows...

#+BEGIN_SRC emacs-lisp :tangle no
(load "chris-davison.el" t)
#+END_SRC

This sets up the load path so that we can override it.  We also install /use-package/ to make all package config easier, and /diminish/, so that I can diminish while installing packages.

#+BEGIN_SRC emacs-lisp
(package-initialize)
(package-refresh-contents)
(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/"))
(unless (assoc-default "org" package-archives)
  (add-to-list 'package-archives '("org" . "https://orgmode.org/elpa/") t))

(setq package-enable-at-startup t)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(eval-when-compile (require 'use-package))
(use-package diminish :ensure t)
(setq use-package-always-ensure t)
(setq use-package-enable-imenu-support t)
(setq lexical-binding t)

(setq
 user-full-name "Chris Davison"
 user-mail-address "c.jr.davison@gmail.com"
 user-emacs-directory "~/code/dotfiles/.emacs.d")
#+END_SRC

* General init
Define a few constants to make it easy to modify behaviour by-system.
#+BEGIN_SRC emacs-lisp
;; Make list-packages take up the entire window
(use-package fullframe :ensure t :defer t
  :config (fullframe list-packages quit-window))

;; Generally useful common-lisp library (functions)
(use-package cl-lib :ensure t :config (require 'cl-lib))
(use-package s :ensure t :defer t)  ; Useful string functions
(use-package f :ensure t :defer t)  ; Useful file and dir functions

;; Make /apropos/ bring up everything, rather than requiring separate keybinds
(setq apropos-do-all t)

(setq-default initial-scratch-message ";; SCRATCH")

(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Delete the current file
#+BEGIN_SRC emacs-lisp
(defun delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (or (buffer-file-name) (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))
#+END_SRC

** Echo path of the current file
#+BEGIN_SRC emacs-lisp
(defun filepath ()
  "Echo the filepath as a message."
  (interactive)
  (message (buffer-file-name)))
#+END_SRC

** Try to make everything UTF8
From [[http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html][here]]
#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

** Popup to help with keybinds
#+BEGIN_SRC emacs-lisp
(use-package guide-key :ensure t :defer t
  :diminish
  :init (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  :config (guide-key-mode 1))
#+END_SRC

* History, Sessions, and Undo

#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups")))
(setq delete-old-versions -1)
(setq version-control t)
(setq vc-make-backup-files t)
(setq auto-save-file-name-transforms
      '((".*" "~/.emacs.d/auto-save-list/" t)))

;; Save minibuffer and other history
(setq savehist-file (expand-file-name "savehist" user-emacs-directory))
(savehist-mode 1)
(setq history-length t)
(setq history-delete-duplicates t)
(setq savehist-save-minibuffer-history 1)
(setq savehist-additional-variables
      '(kill-ring
        search-ring
        regexp-search-ring))

;; Counting 'recent files' as part of history
(use-package recentf :ensure t :defer t
  :config
  (setq recentf-max-saved-items 200
        recentf-max-menu-items 15)
  (recentf-mode))

;; Always save the desktop, the current workspace config
(setq desktop-path (list user-emacs-directory)
      desktop-auto-save-timeout 600
      desktop-restore-frames nil) ; desktop-store-frames will keep themes loaded
(desktop-save-mode 1)

;; Reload when file changed on disk
(global-auto-revert-mode t)

;; Don't create lockfiles.  They're often a hassle
(setq create-lockfiles nil)
#+END_SRC

* Undo Tree - Visualise branches of undos
People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.

This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp
(use-package undo-tree :ensure t :defer t
  :diminish
  :config
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-timestamps nil
        undo-tree-visualizer-diff t))
#+END_SRC

* Magit - Git in Emacs
#+BEGIN_SRC emacs-lisp
(use-package magit :ensure t :defer t
  :config
  (setq
   ;; Magit needs to call git multiple times
   ;; only refreshing the  buffer can improve performance
   magit-refresh-status-buffer nil
   ;; Emacs has its own version control.  We don't need to run both
   ;; as that'll be detrimental for performance
   vc-handled-backends (delq 'Git vc-handled-backends))
  :bind (("C-x g" . magit-status)))
#+END_SRC

A better magit status. Only show magit, and if the currently active file had changes, go to it's unstaged changes section.
#+begin_src emacs-lisp
(defun unpackaged/magit-status ()
  "Open a `magit-status' buffer and close the other window so only Magit is visible.
If a file was visited in the buffer that was active when this
command was called, go to its unstaged changes section."
  (interactive)
  (let* ((buffer-file-path (when buffer-file-name
                             (file-relative-name buffer-file-name
                                                 (locate-dominating-file buffer-file-name ".git"))))
         (section-ident `((file . ,buffer-file-path) (unstaged) (status))))
    (magit-status)
    (delete-other-windows)
    (when buffer-file-path
      (goto-char (point-min))
      (cl-loop until (when (equal section-ident (magit-section-ident (magit-current-section)))
                       (magit-section-show (magit-current-section))
                       (recenter)
                       t)
               do (condition-case nil
                      (magit-section-forward)
                    (error (cl-return (magit-status-goto-initial-section-1))))))))
#+end_src

* Editing
** General Editing Config
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)

(setq find-file-visit-truename t)

;; transparently open compressed files
(auto-compression-mode t)

;; Don't double-space sentences
(set-default 'sentence-end-double-space nil)

;; Use lettercase to determine words in camelcase text
(global-subword-mode 1)
(diminish 'subword-mode)

;; expand region
(use-package expand-region :ensure t)
(define-key global-map (kbd "C-=") 'er/expand-region)

;; If a region is selected, any 'insert' command (typing or yanking) will overwrite it, rather than inserting before.
(delete-selection-mode 1)

;; indent after newline
(global-set-key (kbd "RET") 'newline-and-indent)

;; Interactive editing...over word or region, C-; to edit.  Just modify the symbol, then repeat
;; C-; to exit.
(use-package iedit :ensure t :defer t
  :config (add-hook 'prog-mode-hook 'iedit-mode))

;; snippets
(use-package yasnippet :demand t :defer t
  :diminish yas-minor-mode)
(when (fboundp 'yas-global-mode)
  (yas-global-mode +1))
(diminish 'yas-minor-mode)

(add-hook 'before-save-hook 'delete-trailing-whitespace)
#+END_SRC
** Text filling (paragraph reflowing) and indentation
#+BEGIN_SRC emacs-lisp
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and make it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))

(use-package aggressive-indent :ensure t :defer t
  :config (global-aggressive-indent-mode))
#+END_SRC

** Offer to create parent dirs if they do not exist
[[http://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/][From this blog]]
#+BEGIN_SRC emacs-lisp

(defun my-create-non-existent-directory ()
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions 'my-create-non-existent-directory)
#+END_SRC
** Header templates per filetype
Use ~auto-insert~ when in a new file of that kind to insert header.
#+BEGIN_SRC emacs-lisp
(setq auto-insert-alist
      '(((emacs-lisp-mode . "Emacs lisp mode") nil
         ";;; " (file-name-nondirectory buffer-file-name) " --- " _ "\n\n"
         ";;; Commentary:\n\n"
         ";;; Code:\n\n"
         "(provide '" (substring (file-name-nondirectory buffer-file-name) 0 -3) ")\n"
         ";;; " (file-name-nondirectory buffer-file-name) " ends here\n")
        ((c-mode . "C program") nil
         "/*\n"
         " * File: " (file-name-nondirectory buffer-file-name) "\n"
         " * Description: " _ "\n"
         " */\n\n")
        ((shell-mode . "Shell script") nil
         "#!/bin/bash\n\n"
         " # File: " (file-name-nondirectory buffer-file-name) "\n"
         " # Description: " _ "\n\n")
        ((org-mode . "Org mode") nil
        "#+TITLE: " (read-string "Title: ") "\n"
        "#+AUTHOR: Chris Davison\n"
        "#+EMAIL: c.jr.davison@gmail.com\n"
        "#+OPTIONS: toc:2 num:nil html-postamble:nil\n"
        "#+PROPERTY: header-args :tangle " (read-string "Tangle filename: ") "\n")
        ((python-mode . "Python") nil
        "#!/usr/bin/env python3")
      ))
#+END_SRC
** Move files
#+begin_src emacs-lisp
(defun rename-this-buffer-and-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name))
        (read-file-name-function 'read-file-name-default))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

(defun delete-this-buffer-and-file (force)
  "Delete the file connected to this buffer and kill it, FORCE is universal argument."
  (interactive "P")
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "'%s' is not a file buffer" name)
      (when (or force (yes-or-no-p (format  "Delete '%s', Are you sure? " filename)))
        (delete-file filename)
        (kill-buffer buffer)
        (message "Deleted '%s'" filename)))))
#+end_src
* Programming Language Support - Company and Flycheck
Company will *COMP*lete *ANY*thing. Flycheck basically runs linters and stuff, and lets you know problems in your code.

#+BEGIN_SRC emacs-lisp
(use-package company :ensure t :defer t
  :bind ("TAB" . company-indent-or-complete-common)
  :config
  (setq company-tooltip-align-annotations t)
  (global-company-mode))

(defvar my/company-point nil)
(advice-add 'company-complete-common :before
            (lambda () (setq my/company-point (point))))
(advice-add 'company-complete-common :after
            (lambda ()
              (when (equal my/company-point (point))
                (yas-expand))))

(use-package flycheck :ensure t :defer t
  :config
  (setq-default
   flycheck-disabled-checkers
   (append flycheck-disabled-checkers '(javascript-jshint) '(json-jsonlist))
   flycheck-temp-prefix ".flycheck")
  (flycheck-add-mode 'javascript-eslint 'web-mode)
  (add-hook 'after-init-hook #'global-flycheck-mode))
#+END_SRC
* Terminal Improvements
** Windows Shell Config
Use git-bash as windows shell
#+BEGIN_SRC emacs-lisp
(defun cd/set-windows-shell ()
  "If on windows, set the shell to git bash."
  (interactive)
  (if (eq system-type 'windows-nt)
      (progn (setq explicit-shell-file-name
                   "C:/Program Files/Git/bin/sh.exe")
             (setq shell-file-name "bash")
             (setq explicit-sh.exe-args '("--login" "-i"))
             (setenv "SHELL" shell-file-name)
             (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m))
    nil))

(cd/set-windows-shell)
#+END_SRC
** Improvements for ansi-term
#+BEGIN_SRC emacs-lisp
(defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
  "Close an ansi-term buffer if I quit the terminal."
  (if (memq (process-status proc) '(signal exit))
      (let ((buffer (process-buffer proc)))
        ad-do-it
        (kill-buffer buffer))
    ad-do-it))
(ad-activate 'term-sentinel)

;; By default, use fish in ansi-term
;; e.g. don't prompt for a shell
(defvar my-term-shell "/usr/local/bin/fish")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)

;; Use UTF8 in terminals
(defun my-term-use-utf8 ()
  (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
(add-hook 'term-exec-hook 'my-term-use-utf8)

;; Make URLs in the term clickable
(defun my-term-paste (&optional string)
  (interactive)
  (process-send-string
   (get-buffer-process (current-buffer))
   (if string string (current-kill 0))))

(defun my-term-hook ()
  (goto-address-mode)
  (define-key term-raw-map "\C-y" 'my-term-paste))
(add-hook 'term-mode-hook 'my-term-hook)
#+END_SRC
* Lang - Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode :ensure t :defer t
  :config
  (add-to-list 'auto-mode-alist
               (cons "\\.\\(md\\|markdown\\)\\'" 'markdown-mode))
  (add-hook 'markdown-mode-hook 'visual-line-mode))
#+END_SRC

Use a /let/ binding so that I can Ctrl-g to cancel without leaving characters laying around
#+BEGIN_SRC emacs-lisp
(defun cd/yank-md ()
  "Yank a markdown link and enter a description for it."
  (interactive)
  (let ((desc (read-string "Description: ")))
    (insert "[")
    (insert desc)
    (insert "](")
    (yank)
    (insert ")")))
(global-set-key (kbd "<f5>") 'cd/yank-md)
#+END_SRC
* Lang - LISP -- Clojure and Cider
#+BEGIN_SRC emacs-lisp :tangle no
;; Cider for interactive clojure programming
(use-package flycheck-clojure :ensure t :defer t)
(use-package cider :ensure t :defer t
  :config
  (setq nrepl-popup-stacktraces nil)
  (with-eval-after-load 'cider
    (add-hook 'cider-mode-hook 'eldoc-mode)
    (add-hook 'cider-repl-mode-hook 'subword-mode)
    (add-hook 'cider-repl-mode-hook 'smartparens-mode)
    (add-hook 'cider-repl-mode-hook 'paredit-mode)
    (with-eval-after-load 'clojure-mode
      (with-eval-after-load 'flycheck
        (flycheck-clojure-setup)))))
#+END_SRC
* Lang - Go
#+BEGIN_SRC emacs-lisp
(use-package go-mode :ensure t :defer t
  :config
  (add-hook 'before-save-hook 'gofmt-before-save)
  (setq gofmt-command "goimports"))
#+END_SRC
* Lang - Rust / Racer config
Auto-completion for rust, using racer
#+BEGIN_SRC emacs-lisp
(use-package rust-mode :ensure t :defer t)
(use-package flymake-rust :ensure t :defer t)
(use-package flycheck-rust :ensure t :defer t)
(use-package cargo :ensure t :defer t)
(use-package racer :defer t
  :ensure t
  :config
  (setq racer-cmd "/Users/davison/prog/z__NOT_MINE/racer/target/release/racer")
  (setq racer-rust-src-path "/Users/davison/prog/z__NOT_MINE/rust_1.3_src/src/")
  (add-hook 'rust-mode-hook 'racer-mode)
  (add-hook 'racer-mode-hook 'eldoc-mode)
  (add-hook 'rust-mode-hook 'cargo-minor-mode)
  (add-hook 'racer-mode-hook 'company-mode))

#+END_SRC
* Lang - Python
Use elpy for python
#+BEGIN_SRC emacs-lisp
;; (use-package elpy :ensure t :defer t :disable t
;;   :config
;;   (add-hook 'python-mode-hook (lambda () (elpy-enable)))
;;   (setq python-shell-interpreter "ipython"
;;         python-shell-interpreter-args "--simple-prompt -i"))
(use-package pyvenv :ensure t :defer t)
(use-package anaconda-mode :ensure t :defer t
  :config
  (add-hook 'python-mode-hook 'anaconda-mode))
(use-package company-anaconda :ensure t :defer t)
(eval-after-load "company" '(add-to-list 'company-backends 'company-anaconda))

(defun ipython()
  (interactive)
  (if (eq system-type 'windows-nt)
      (progn (setq explicit-shell-file-name
                   "C:/python3/scripts/ipython.exe")
             (setq shell-file-name "ipython")
             (setq explicit-sh.exe-args '("--login" "-i"))
             (setenv "SHELL" shell-file-name)
             (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)
             (shell)
             (cd/set-windows-shell))
    (ansi-term "~/.envs/ml/bin/ipython" "ipython")))

(add-to-list 'python-shell-exec-path "~/.envs/ml/bin/")
#+END_SRC
* TODO Lang - Latex
#+BEGIN_SRC emacs-lisp
(use-package auctex :ensure t :defer t
  :config
  (setq TeX-auto-save t
        TeX-parse-self t
        TeX-save-query nil
        ispell-program-name "aspell"
        ispell-dictionary "english")
  (add-hook 'LaTeX-mode-hook 'flyspell-mode)
  (add-hook 'LaTeX-mode-hook 'flyspell-buffer)
  (add-hook 'LaTeX-mode-hook '(lambda () (outline-minor-mode 1))
            (add-hook 'latex-mode-hook 'visual-line-mode)))

  ;; Manage citations
  (require 'tex-site)
  (autoload 'reftex-mode "reftex" "RefTeX Minor Mode" t)
  (autoload 'turn-on-reftex "reftex" "RefTeX Minor Mode" nil)
  (autoload 'reftex-citation "reftex-cite" "Make citation" nil)
  (autoload 'reftex-index-phrase-mode "reftex-index" "Phrase Mode" t)
  (add-hook 'latex-mode-hook 'turn-on-reftex)
  (add-hook 'LaTeX-mode-hook 'turn-on-reftex)

  (setq LaTeX-eqnarray-label "eq"
        LaTeX-equation-label "eq"
        LaTeX-figure-label "fig"
        LaTeX-table-label "tab"
        LaTeX-myChapter-label "chap"
        TeX-auto-save t
        TeX-newline-function 'reindent-then-newline-and-indent
        TeX-parse-self t
        TeX-style-path '("style/" "auto/"
                         "/usr/share/emacs21/site-lisp/auctex/style/"
                         "/var/lib/auctex/emacs21/"
                         "/usr/local/share/emacs/site-lisp/auctex/style/")
        LaTeX-section-hook '(LaTeX-section-heading
                             LaTeX-section-title
                             LaTeX-section-toc
                             LaTeX-section-section
                             LaTeX-section-label))
#+END_SRC
* TODO Lang - Julia
#+BEGIN_SRC emacs-lisp :tangle no
(use-package julia-mode :ensure t :defer t)
(use-package julia-repl :ensure t :defer t
  :config
  (add-hook 'julia-mode-hook 'julia-repl-mode))

(add-to-list 'load-path "C:/Julia-1.1.0/bin")
(if (eq system-type 'windows-nt)
    (setq julia-repl-executable-records '((default "julia.exe" :basedir "C:/Julia-1.1.0/bin" ))))

;; (setq julia-repl-executable-records '((default "julia")))
#+END_SRC
* Lang - Web-stuff
#+BEGIN_SRC emacs-lisp
(use-package sass-mode :ensure t :defer t)
(use-package js2-mode :ensure t :defer t)

;; Colourize CSS literals
(use-package rainbow-mode :ensure t :defer t
  :config
  (add-hook 'css-mode-hook 'rainbow-mode)
  (add-hook 'html-mode-hook 'rainbow-mode)
  (add-hook 'sass-mode-hook 'rainbow-mode))
#+END_SRC
* Lang - Elixir
#+begin_src emacs-lisp
(use-package alchemist :ensure t)
#+end_src
* Navigation (ivy, counsel, swiper, imenu anywhere))

Navigation of pretty much any /menu-type/ thing.

- =Ivy= and =counsel= make things like ~M-x~ and grep easier.
- =swiper= is a popup search of the current buffer.
- =imenu-anywhere= will search for headings/functions recursively over all files of the same /mode/

#+BEGIN_SRC emacs-lisp
(use-package ivy :ensure t :defer t
             :diminish
             :bind
             (:map ivy-mode-map
                   ("C-c h" . ivy-switch-buffer)
                   ("C-c s" . swiper))
             :config
             (ivy-mode 1)
             (setq ivy-use-virtual-buffers t
                   ivy-height 15
                   ivy-count-format ""
                   ivy-initial-inputs-alist nil
                   ivy-re-builders-alist
                   '((t . ivy--regex-plus))))

(use-package counsel :ensure t :defer t
             :bind*
             (("C-x f" . counsel-find-file)
              ("C-c i" . counsel-imenu)
              ("C-c a" . counsel-rg)
              ("C-c g s" . counsel-grep-or-swiper)
              ("C-c b" . counsel-descbinds)
              ("M-x" . counsel-M-x))
             :config
             (setq counsel-grep-base-command
                   "rg -i -M 120 --no-heading --line-number --color never '%s' %s"))

(use-package swiper :ensure t :defer t)
(use-package imenu-anywhere :ensure t :defer t)

(use-package dumb-jump :ensure t
             :config
             (add-hook 'prog-mode-hook 'dumb-jump-mode))
#+END_SRC
* Navigate between windows
Give HUD prompt when changing window, and keybind to cycle through windows.

#+BEGIN_SRC emacs-lisp
;; Prompt with a hud when switching windows, if more than 2 windows
(use-package switch-window :defer t
  :ensure t
  :bind ("C-x o" . switch-window))

;; cycle through 'windows' (e.g. panes)
(define-key global-map (kbd "M-`") 'next-multiframe-window)
(define-key global-map (kbd "C-M-`") 'previous-multiframe-window)
#+END_SRC

* ibuffer -- show version control status of file
#+BEGIN_SRC emacs-lisp
;; Interactively modify buffer list
(use-package fullframe :ensure t :defer t)
(with-eval-after-load 'buffer (fullframe ibuffer ibuffer-quit))

(use-package ibuffer-vc :ensure t)
(defun ibuffer-set-up-preferred-filters ()
  (ibuffer-vc-set-filter-groups-by-vc-root)
  (unless (eq ibuffer-sorting-mode 'filename/process)
    (ibuffer-do-sort-by-filename/process)))

(add-hook 'ibuffer-hook 'ibuffer-set-up-preferred-filters)

(with-eval-after-load 'ibuffer
  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     (t (format "%8d" (buffer-size)))))
  ;; Explicitly require ibuffer-vc to get its column definitions, which
  ;; can't be autoloaded
  (require 'ibuffer-vc))

;; Modify the default ibuffer-formats (toggle with `)
(setq ibuffer-formats
      '((mark modified read-only vc-status-mini " "
              (name 18 18 :left :elide) " "
              (size-h 9 -1 :right) " "
              (mode 16 16 :left :elide) " "
              (vc-status 16 16 :left) " "
              filename-and-process)
        (mark modified read-only vc-status-mini " "
              (name 18 18 :left :elide) " "
              (size-h 9 -1 :right) " "
              (mode 16 16 :left :elide) " "
              filename-and-process)))
(setq ibuffer-filter-group-name-face 'font-lock-doc-face)
(global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC
* isearch -- live preview of search and replace
#+BEGIN_SRC emacs-lisp
;; Show current and total matches while searching
(use-package anzu :defer t
  :diminish
  :ensure t
  :bind (([remap query-replace-regexp] . anzu-query-replace-regexp)
         ([remap query-replace] . anzu-query-replace)
         ;; Invert regex and normal isearch
         ("C-M-%" . anzu-query-replace)
         ("M-%" . anzu-query-replace-regexp))
  :config (global-anzu-mode t))

;; DEL during isearch should edit the search string, not jump back to the previous result
(define-key isearch-mode-map [remap isearch-delete-char] 'isearch-del-char)
#+END_SRC

* OSX
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (use-package exec-path-from-shell :ensure t
    :config
    (when (memq window-system '(mac ns))
      (exec-path-from-shell-initialize))
    (exec-path-from-shell-copy-env "GOPATH"))

  (setq mac-command-modifier 'meta
        mac-option-modifier 'none
        default-input-method "MacOSX")

  ;;Make the mouse wheel/trackpad less jerky
  (setq mouse-wheel-scroll-amount '(1 ((shift) . 5) ((control))))
  (dolist (multiple '("" "double-" "triple-"))
    (dolist (direction '("right" "left"))
      (global-set-key (kbd (concat "<" multiple "wheel-" direction ">")) 'ignore)))

  ;;And give emacs some of the expected OS X keybinds
  (global-set-key (kbd "M-h") 'ns-do-hide-emacs)
  (global-set-key (kbd "M-˙") 'ns-do-hide-others)
  (with-eval-after-load 'nxml-mode (define-key nxml-mode-map (kbd "M-h") nil))
  (global-set-key (kbd "M-ˍ") 'ns-do-hide-others) ;; what describe-key reports for cmd-option-h
  (global-set-key (kbd "M-<up>") 'toggle-frame-fullscreen) ;;Bind Meta-<UP> to fullscreen toggling
  (global-set-key (kbd "<f10>") 'toggle-frame-fullscreen) ;;Bind Meta-<UP> to fullscreen toggling
  )
#+END_SRC
* Org-mode
Org-mode is a really powerful notetaking tool.

You can easily /capture/ information using various different templates (including custom templates), and then refile them to perhaps a more appropriate location,

/Agenda/ lets you schedule and deadline tasks.
** General Org Config

#+BEGIN_SRC emacs-lisp
(defun cd/org-open-link-same ()
  (interactive)
  (let ((old-setup org-link-frame-setup))
    (setq org-link-frame-setup '((file . find-file)))
    (org-open-at-point)
    (setq org-link-frame-setup old-setup)))

(use-package org
  :ensure t
  :pin org
  :bind (("<f1>" . org-capture)
         ("<f2>" . org-agenda)
         ("<f3>" . org-agenda-list)
         ("C-c l" . org-store-link)
         ("C-c S-O" . cd/org-open-link-same))
  :config
  (setq org-directory "~/Dropbox/notes"
        org-default-notes-file "~/Dropbox/notes/inbox.org"
        org-src-window-setup 'current-window
        org-agenda-window-setup 'current-window
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-confirm-babel-evaluate nil
        org-edit-src-content-indentation 0
        org-catch-invisible-edits 'show-and-error
        org-imenu-depth 3
        ;; Use M-+ M-- to change todo, and leave S-<arrow> for windows
        org-replace-disputed-keys t
        inhibit-compacting-font-caches t
        org-hide-emphasis-markers t
        org-todo-keywords'((sequence "TODO" "WIP" "|" "DONE")
                           (sequence "|" "CANCELLED")
                           (sequence "|" "BACKBURNER"))
        org-agenda-skip-scheduled-if-done t
        org-startup-indented t
        org-hide-leading-stars t
        org-cycle-separator-lines 0
        org-list-indent-offset 1
        org-modules '(org-bibtex org-habit)
        org-agenda-files '("~/Dropbox/notes/inbox.org"
                           "~/Dropbox/notes/work.org"
                           "~/Dropbox/notes/calendar.org"
                           "~/Dropbox/notes/logbook.org")
        org-log-done 'time
        org-ellipsis "…"
        org-archive-location "~/Dropbox/notes/archive.org::")
  (org-babel-do-load-languages
   'org-babel-load-languages '((python . t)
                               (sqlite . t)
                               (emacs-lisp . t)))
  (setq org-confirm-babel-evaluate nil)
  ;; Settings for refiling
  (setq org-reverse-note-order t
        org-refile-use-outline-path nil
        org-refile-allow-creating-parent-nodes 'confirm
        org-refile-use-cache nil
        org-refile-targets '((org-agenda-files . (:maxlevel . 3)))
        org-blank-before-new-entry nil)
  (set-face-attribute 'org-block-begin-line nil :height 0.7 :slant 'normal)
  :hook ((org-mode . visual-line-mode)
         (org-mode . org-indent-mode)
         (org-mode . abbrev-mode)))

(diminish 'org-indent-mode)


(defun cd/org-agenda-all ()
  (interactive)
  (let ((old-agenda-list org-agenda-files))
    (setq org-agenda-files '("~/Dropbox/notes/"))
    (org-agenda-list)
    (setq org-agenda-files old-agenda-list)))
#+END_SRC
** Insert a link from clipboard
Prompt for description. Basically slightly quicker than having to ~C-y~ when creating a link.
#+BEGIN_SRC emacs-lisp
;; (use-package ox-reveal :ensure t)
(defun insert-link-with-description-prompt ()
  "Yank into an org link."
  (interactive)
  (let ((description (read-string "Description: ")))
    (insert "[[")
    (yank)
    (insert (s-concat "][" description "]]"))))
#+END_SRC
** Fix indentation for org source blocks
#+BEGIN_SRC emacs-lisp
(defun cd/org-cleanup ()
  (interactive)
  (org-edit-special)
  (indent-region (point-min) (point-max))
  (org-edit-src-exit))
(global-set-key (kbd "C-x c") 'cd/org-cleanup)
#+END_SRC
** Templates for src/latex/etc blocks
#+BEGIN_SRC emacs-lisp
(setq org-structure-template-alist
      (if (string-greaterp (org-version) "9.2")
          '(("a" . "export ascii")
            ("c" . "center")
            ("C" . "comment")
            ("e" . "example")
            ("E" . "export")
            ("h" . "export html")
            ("l" . "src emacs-lisp")
            ("q" . "quote")
            ("s" . "src")
            ("v" . "verse")
            ("V" . "verbatim"))
        '(("a" "#+BEGIN_EXPORT ascii\n?\n#+END_EXPORT")
          ("c" "#+BEGIN_CENTER\n?\n#+END_CENTER")
          ("C" "#+BEGIN_COMMENT\n?\n#+END_COMMENT")
          ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE")
          ("E" "#+BEGIN_EXPORT\n?\n#+END_EXPORT")
          ("h" "#+BEGIN_EXPORT html\n?\n#+END_EXPORT")
          ("l" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
          ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE")
          ("s" "#+BEGIN_SRC\n?\n#+END_SRC")
          ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE")
          ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM"))
        ))
#+END_SRC
** Move to prev/next narrow
#+BEGIN_SRC emacs-lisp
(defun cd/move-to-previous-narrow ()
  (interactive)
  (progn
    (beginning-of-buffer)
    (widen)
    (outline-previous-heading)
    (org-narrow-to-subtree)))

(defun cd/move-to-next-narrow ()
  (interactive)
  (progn
    (beginning-of-buffer)
    (widen)
    (outline-next-heading)
    (org-narrow-to-subtree)))
#+END_SRC
** Capture templates
#+BEGIN_SRC emacs-lisp
(setq org-capture-templates
      '(
        ("t" "Todo (ME)" entry
         (file+headline "~/Dropbox/notes/inbox.org" "TASKS")
         "* TODO %^{TASK}\n%?" :empty-lines-after 1)

        ("w" "Todo (WORK)" entry
         (file "~/Dropbox/notes/work.org")
         "* TODO %^{PROJECT}\n%?" :empty-lines-after 1)

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ("n" "Note" entry
         (file+headline "~/Dropbox/notes/inbox.org" "Notes")
         "* %^{Title}\n%?" :empty-lines 1)
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ;; Datetree of YYYY / YYYY-MM MONTHNAME / YYYY-MM-DD DAYNAME
        ("l" "Logbook" item
         (file+datetree "~/Dropbox/notes/logbook.org")
         "%?" :tree-type week)
        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ("Q" "Quote" entry
         (file+headline "~/Dropbox/notes/quotes.org" "UNFILED")
         "* %^{Topic}\n#+BEGIN_QUOTE\n%^{Quote} (%^{Author})\n#+END_QUOTE"
         :immediate-finish 1)

        ("u" "URL" item
         (file+olp "~/Dropbox/notes/inbox.org" "Notes" "Links")
         "[[%^{URL}][%^{Description}]]"
         :immediate-finish 1)

        ("a" "Article" entry
         (file+headline "~/Dropbox/notes/work.org" "Literature")
         "* TODO %^{Title}\n\nAbstract: %?"
         :prepend t :created t)

        ("c" "Code Snippet" entry
         (file+headline "~/Dropbox/notes/inbox.org" "Code Snippets")
         "* %^{Snippet Topic}\n#+BEGIN_SRC %^{Language}\n%c\n#+END_SRC\n"
         :immediate-finish 1)

        ("e" "Calendar Event" entry
         (file "~/Dropbox/notes/calendar.org")
         "* %^T %^{EVENT}\n%?")

        ("f" "Film" entry
         (file "~/Dropbox/notes/films-to-watch.org")
         "* TODO %^{Title} (%^{YEAR})\n%?"
         :prepend t :created t)

        ("b" "Book" entry
         (file+headline "~/Dropbox/notes/reading-list.org" "UNFILED")
         "* Buy %^{Title}\n*Author(s)*: %^{AUTHORS}\n%?"
         :prepend t :created t)
        ))
#+END_SRC
** Update checkboxes on save
#+BEGIN_SRC emacs-lisp
(defun custom_org_auto_check()
  (org-update-checkbox-count t))
(add-hook 'org-mode-hook
          (lambda ()
             (add-hook 'after-save-hook 'custom_org_auto_check nil 'make-it-local)))
#+END_SRC
** TODO org-return-dwim

NOT tangling this for now as I'm finding it a bit weird to get used to. May keep in all the stuff about lists etc, but remove the configuration for headers, or at least simplify it.

#+begin_src emacs-lisp :tangle no

(defun unpackaged/org-element-descendant-of (type element)
  "Return non-nil if ELEMENT is a descendant of TYPE.
TYPE should be an element type, like `item' or `paragraph'.
ELEMENT should be a list like that returned by `org-element-context'."
  (-when-let* ((parent (org-element-property :parent element)))
    (or (eq type (car parent))
        (unpackaged/org-element-descendant-of type parent))))

(defun unpackaged/org-return-dwim (&optional default)
  "A helpful replacement for `org-return'.  With prefix, call `org-return'.

On headings, move point to position after entry content.  In
lists, insert a new item or end the list, with checkbox if
appropriate.  In tables, insert a new row or end the table."
  ;; Inspired by John Kitchin: http://kitchingroup.cheme.cmu.edu/blog/2017/04/09/A-better-return-in-org-mode/
  (interactive "P")
  (if default
      (org-return)
    (cond
     ;; Act depending on context around point.

     ;; NOTE: I prefer RET to not follow links, but by uncommenting this block, links will be
     ;; followed.

     ;; ((eq 'link (car (org-element-context)))
     ;;  ;; Link: Open it.
     ;;  (org-open-at-point-global))

     ((org-at-heading-p)
      ;; Heading: Move to position after entry content.
      ;; NOTE: This is probably the most interesting feature of this function.
      (let ((heading-start (org-entry-beginning-position)))
        (goto-char (org-entry-end-position))
        (cond ((and (org-at-heading-p)
                    (= heading-start (org-entry-beginning-position)))
               ;; Entry ends on its heading; add newline after
               (end-of-line)
               (insert "\n\n"))
              (t
               ;; Entry ends after its heading; back up
               (forward-line -1)
               (end-of-line)
               (when (org-at-heading-p)
                 ;; At the same heading
                 (forward-line)
                 (insert "\n")
                 (forward-line -1))
               (while (not (looking-back (rx (repeat 3 (seq (optional blank) "\n")))))
                 (insert "\n"))
               (forward-line -1)))))

     ((org-at-item-checkbox-p)
      ;; Checkbox: Insert new item with checkbox.
      (org-insert-todo-heading nil))

     ((org-in-item-p)
      ;; Plain list.  Yes, this gets a little complicated...
      (let ((context (org-element-context)))
        (if (or (eq 'plain-list (car context))  ; First item in list
                (and (eq 'item (car context))
                     (not (eq (org-element-property :contents-begin context)
                              (org-element-property :contents-end context))))
                (unpackaged/org-element-descendant-of 'item context))  ; Element in list item, e.g. a link
            ;; Non-empty item: Add new item.
            (org-insert-item)
          ;; Empty item: Close the list.
          ;; TODO: Do this with org functions rather than operating on the text. Can't seem to find the right function.
          (delete-region (line-beginning-position) (line-end-position))
          (insert "\n"))))

     ((when (fboundp 'org-inlinetask-in-task-p)
        (org-inlinetask-in-task-p))
      ;; Inline task: Don't insert a new heading.
      (org-return))

     ((org-at-table-p)
      (cond ((save-excursion
               (beginning-of-line)
               ;; See `org-table-next-field'.
               (cl-loop with end = (line-end-position)
                        for cell = (org-element-table-cell-parser)
                        always (equal (org-element-property :contents-begin cell)
                                      (org-element-property :contents-end cell))
                        while (re-search-forward "|" end t)))
             ;; Empty row: end the table.
             (delete-region (line-beginning-position) (line-end-position))
             (org-return))
            (t
             ;; Non-empty row: call `org-return'.
             (org-return))))
     (t
      ;; All other cases: call `org-return'.
      (org-return)))))

;; If -when-let* isn't bound (e.g. no dash installed)
;; just use the default return behaviour
(when (fboundb '-when-let*)
  (define-key org-mode-map (kbd "RET") 'unpackaged/org-return-dwim))
#+end_src
* Hydra -- General utility HUDs
#+BEGIN_SRC emacs-lisp
(use-package hydra :ensure t :defer t)
#+END_SRC

* Hydra -- Dired
#+BEGIN_SRC emacs-lisp
(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              _f_ilter           ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("f" (progn
         (dired-mark-files-regexp (read-string "Regexp: "))
         (dired-toggle-marks)
         (dired-do-kill-lines)) :exit t)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(with-eval-after-load 'dired
  (define-key dired-mode-map "." 'hydra-dired/body))

#+END_SRC
* Hydra -- Ibuffer
#+BEGIN_SRC emacs-lisp
(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
  _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
 _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
  _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
"
  ("j" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("k" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" quit-window "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                              :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                :after-exit
                                (if (eq major-mode 'ibuffer-mode)
                                    (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(add-hook 'after-init-hook (lambda ()
    (define-key ibuffer-mode-map "." 'hydra-ibuffer-main/body)))

(add-hook 'ibuffer-hook 'hydra-ibuffer-main/body)
#+END_SRC
* Hydra -- My utility binds
#+BEGIN_SRC emacs-lisp
(defhydra cd/hydra/windowmove (:exit t :hint nil)
  "
  Split _R_ight/_D_own :: _n_ext/_p_rev narrowed subtree :: _<_|_>_indent
  "
  ("R" (progn (split-window-right) (windmove-right)))
  ("D" (progn (split-window-below) (windmove-down)))
  ("n" cd/move-to-next-narrow :exit nil)
  ("p" cd/move-to-previous-narrow :exit nil)
  (">" indent-rigidly-right-to-tab-stop :exit nil)
  ("<" indent-rigidly-left-to-tab-stop :exit nil))

(defhydra cd/hydra/files (:exit t :hint nil :color pink)
  "
  _i_nbox _w_ork _l_ogbook _a_rchive _c_onfig _e_vents
  "
  ("i" (find-file "~/Dropbox/notes/inbox.org"))
  ("w" (find-file "~/Dropbox/notes/work.org"))
  ("l" (find-file "~/Dropbox/notes/logbook.org"))
  ("a" (find-file "~/Dropbox/notes/archive.org"))
  ("e" (find-file "~/Dropbox/notes/calendar.org"))
  ("c" (find-file "~/code/dotfiles/.emacs.d/chris-davison.org")))

(defhydra cd/hydra/main (:hint nil :exit t)
  "
  _f_old _F_OLD ~ _z_oom ~ (_w_indow) ~ Join_<up>_/_<down>_
  _s_wipe _i_menu ~ _r_eplace i_e_dit ~ _b_ookmarks ~ org _a_genda
  "
  ("f" yafolding-toggle-element)
  ("F" yafolding-toggle-all)
  ("z" (modi/toggle-one-window nil))
  ("w" cd/hydra/windowmove/body)
  ("s" counsel-grep-or-swiper)
  ("r" anzu-query-replace-regexp)
  ("i" ivy-imenu-anywhere)
  ("e" iedit-mode)
  ("b" cd/hydra/files/body)
  ("o" cd/hydra/files/body)
  ("a" org-agenda)
  ("<up>" delete-indentation :exit nil)
  ("<down>" (join-line -1) :exit nil))

(define-key global-map (kbd "C-z") 'cd/hydra/main/body)
#+END_SRC
* Suppress GUI features
#+BEGIN_SRC emacs-lisp
(setq use-file-dialog nil
      use-dialog-box nil
      menu-bar-mode nil
      inhibit-startup-screen t
      inhibit-startup-echo-area-message t)
(add-hook 'after-init-hook '(lambda () (menu-bar-mode -1)))

;; Hide tool bar,  scroll bar and borders
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'set-scroll-bar-mode) (set-scroll-bar-mode nil))

(let ((no-border '(internal-border-width . 0)))
  (add-to-list 'default-frame-alist no-border)
  (add-to-list 'initial-frame-alist no-border))
#+END_SRC

* Font
List some pretty fonts, and grab the first one that's available.
#+BEGIN_SRC emacs-lisp
(setq cd-font-options
      '("Fantasque Sans Mono"
        "Ubuntu Mono"
        "Roboto Mono"
        "DejaVu Sans Mono"
        "Fira Code"
        "Liberation Mono"))
(setq cd-fonts-available
      (cl-remove-if
       (lambda (font)
         (not (member font (font-family-list)))) cd-font-options))
(when cd-fonts-available
  (set-frame-font (car cd-fonts-available) 1))

(defvar current-font-idx 0)
(defun next-font ()
  (interactive)
  (setq current-font-idx
        (% (+ 1 current-font-idx)
           (length cd-fonts-available)))
  (let ((next-font-name (nth current-font-idx cd-fonts-available)))
    (set-frame-font next-font-name 1)
    (message next-font-name)))


(setq line-spacing 0)
(setq cd-font-height
      (if (eq system-type 'windows-nt) 160 200))
(set-face-attribute 'default nil :height cd-font-height)
(setq auto-window-vscroll nil)
#+END_SRC
* Colour themes
Disable themes before loading a new theme
#+BEGIN_SRC emacs-lisp
(defadvice load-theme (before theme-dont-propagate activate)
  (mapc #'disable-theme custom-enabled-themes))
(setq custom-safe-themes t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package kaolin-themes)
(use-package color-theme-sanityinc-solarized)
;;(load-theme 'kaolin-dark t)
;;(load-theme 'kaolin-bubblegum t)
(load-theme 'kaolin-temple t)
;;(load-theme 'kaolin-valley-light t)
;;(load-theme 'sanityinc-solarized-dark t)
#+END_SRC
* Appearance
** Line highlighting, linum, colnum, and cursor
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
(blink-cursor-mode 0)
(setq linum-format "%d ")

;; Line number and column
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC
** Tabstop stuff
#+BEGIN_SRC emacs-lisp
(setq tab-stop-list (number-sequence 4 200 4))
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+END_SRC
** Don't scroll jump multiple lines
#+BEGIN_SRC emacs-lisp
(setq scroll-step           1
      scroll-conservatively 10000)
#+END_SRC
** Temporary 'zoom' into a pane
A bit like 'focus mode' for other languages.  Can perhaps combine this with /darkroom/ to enforce distraction free writing.

From [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-windows-buffers.el][this github repo]].
#+BEGIN_SRC emacs-lisp
(defvar modi/toggle-one-window--buffer-name nil
  "Variable to store the name of the buffer for which the `modi/toggle-one-window'
function is called.")

(defvar modi/toggle-one-window--window-configuration nil
  "Variable to store the window configuration before `modi/toggle-one-window'
function was called.")

(defun modi/toggle-one-window (&optional force-one-window)
  "Toggles the frame state between deleting all windows other than
the current window and the windows state prior to that."
  (interactive "P")
  (if (or (null (one-window-p))
          force-one-window)
      (progn
        (setq modi/toggle-one-window--buffer-name (buffer-name))
        (setq modi/toggle-one-window--window-configuration (current-window-configuration))
        (delete-other-windows))
    (progn
      (when modi/toggle-one-window--buffer-name
        (set-window-configuration modi/toggle-one-window--window-configuration)
        (switch-to-buffer modi/toggle-one-window--buffer-name)))))
  (define-key global-map (kbd "C-x 1") 'modi/toggle-one-window)

#+END_SRC
** Code-folding
#+BEGIN_SRC emacs-lisp
;; Code folding
(use-package yafolding :ensure t)
(add-hook 'prog-mode-hook 'yafolding-mode)
(use-package fold-dwim :ensure t :defer t)
(use-package fold-dwim-org :ensure t :defer t)
(add-hook 'prog-mode-hook 'fold-dwim-org/minor-mode)
#+END_SRC
** OTHER appearance stuff
#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
(setq linum-format "%4d ")

(set-default 'indicate-empty-lines t)

;; Soft-wrap at a column.
;; Not currently setting this globally, as still unsure about
;; hard wrap vs soft-wrap vs soft-wrap with ruler
(use-package visual-fill-column :ensure t
  :config
  (setq visual-fill-column-width 80))

;; Replace lambda and AND etc with pretty symbols
(global-prettify-symbols-mode +1)

(use-package smart-mode-line :ensure t :config )
(add-hook 'after-init-hook 'sml/setup)
#+END_SRC
* WIP TESTING GROUND

#+NAME: TESTING
#+BEGIN_SRC emacs-lisp :tangle no
(use-package company-box :ensure t :defer t)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun cd/python-comment-header ()
  (interactive)
  (let* ((header (read-string "Header: "))
         (border (s-repeat (length header) "="))
         (indentation (s-repeat (current-column) " ")))
    (insert "# " border
            "\n" indentation "# " header
            "\n" indentation "# " border)))))
(define-key python-mode-map (kbd "C-c C-h") 'cd/python-comment-header)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(define-abbrev-table 'global-abbrev-table
  '(
    ("afaict" "as far as I can tell" nil 1)
    ("btw" "by the way" nil 0)
    ("wether" "whether" nil 3)
    ("mustd" "μ±σ" nil 1)
    ))
(define-abbrev-table 'latex-mode-abbrev-table
  '(
    ("mustd" "\\(\\mu \\pm \\sigma\\)" nil 0)
    ))
#+END_SRC

Use multiple cursors

#+BEGIN_SRC emacs-lisp
(use-package multiple-cursors :ensure t :defer t
:hook ((prog-mode . multiple-cursors-mode)))
#+END_SRC
