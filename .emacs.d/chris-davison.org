#+TITLE: Chris Davison's Emacs Config
#+PROPERTY: header-args emacs-lisp :tangle yes :results silent

* Configuration

You /tangle/ this file, using org-babel ~C-c C-v t~, which will create ~chris-davison.el~.  This file can either be loaded from an ~init.el~ (using ~(load "chris-davison.el" t)~), or by directly symlinking ~chris-davison.el~ to ~init.el~.  The symlinking may be a bit iffy on platforms like windows...

# #+BEGIN_SRC emacs-lisp
# (load "chris-davison.el" t)
# #+END_SRC

This sets up the load path so that we can override it.  We also install /use-package/ to make all package config easier.

#+BEGIN_SRC emacs-lisp
(package-initialize)

(setq gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3")

(package-refresh-contents)

(add-to-list 'package-archives '("melpa" . "http://melpa.org/packages/") t)
(add-to-list 'package-archives '("org" . "http://orgmode.org/elpa/") t)

(setq package-enable-at-startup t)
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))
(setq-default use-package-enable-imenu-support t)
(setq use-package-always-ensure t)
(eval-when-compile (require 'use-package))
(setq lexical-binding t)

(setq
 user-full-name "Chris Davison"
 user-mail-address "c.jr.davison@gmail.com"
 user-emacs-directory "~/code/dotfiles/.emacs.d"
 config-file (expand-file-name "chris-davison.org" user-emacs-directory))

(defun if-exists-kill-buffer (buffer)
  "If a buffer matching BUFFER exists, kill it"
  (when (get-buffer buffer)
    (kill-buffer buffer)))

(defun file-name-new-extension (filename ext)
  "Replace extension of FILENAME with EXT"
  (concat (file-name-sans-extension filename) ext))

(defun eval-config ()
  "Tangle my org-mode config and then immediately evaluate"
  (interactive)
  (let* ((config-el (file-name-new-extension config-file ".el")))
    (if-exists-kill-buffer (file-name-base config-el))
    (org-babel-tangle-file config-file)
    (load config-el t)))
#+END_SRC

* General init
Define a few constants to make it easy to modify behaviour by-system.
#+BEGIN_SRC emacs-lisp
;; Make list-packages take up the entire window
(use-package fullframe :ensure t :defer t
  :config (fullframe list-packages quit-window))

;; Generally useful common-lisp library (functions)
(use-package cl-lib :ensure t :config (require 'cl-lib))
(use-package s :ensure t :defer t)  ; Useful string functions
(use-package f :ensure t :defer t)  ; Useful file and dir functions
(use-package diminish :ensure t)

;; Make /apropos/ bring up everything, rather than requiring separate keybinds
(setq apropos-do-all t)

(setq-default initial-scratch-message ";; SCRATCH")

(defalias 'yes-or-no-p 'y-or-n-p)
#+END_SRC

** Delete the current file
#+BEGIN_SRC emacs-lisp
(defun delete-this-file ()
  "Delete the current file, and kill the buffer."
  (interactive)
  (or (buffer-file-name) (error "No file is currently being edited"))
  (when (yes-or-no-p (format "Really delete '%s'?"
                             (file-name-nondirectory buffer-file-name)))
    (delete-file (buffer-file-name))
    (kill-this-buffer)))
#+END_SRC

** Echo path of the current file
#+BEGIN_SRC emacs-lisp
(defun filepath ()
  "Echo the filepath as a message."
  (interactive)
  (message (buffer-file-name)))
#+END_SRC

** Try to make everything UTF8
From [[http://www.wisdomandwonder.com/wordpress/wp-content/uploads/2014/03/C3F.html][here]]
#+BEGIN_SRC emacs-lisp
(setq locale-coding-system 'utf-8)
(set-terminal-coding-system 'utf-8)
(set-keyboard-coding-system 'utf-8)
(set-selection-coding-system 'utf-8)
(prefer-coding-system 'utf-8)
(when (display-graphic-p)
  (setq x-select-request-type '(UTF8_STRING COMPOUND_TEXT TEXT STRING)))
#+END_SRC

** Popup to help with keybinds
#+BEGIN_SRC emacs-lisp
(use-package guide-key :ensure t :defer t
  :init (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-c"))
  :config (guide-key-mode 1))
#+END_SRC

* Persistence (history, sessions, version control)
** General session and history settings
#+BEGIN_SRC emacs-lisp
(setq backup-directory-alist '(("." . "~/.emacs.d/backups"))
      delete-old-versions -1
      version-control t
      vc-make-backup-files t
      auto-save-file-name-transforms '((".*" "~/.emacs.d/auto-save-list/" t)))

;; Save minibuffer and other history
(setq savehist-file (expand-file-name "savehist" user-emacs-directory)
      history-length t
      history-delete-duplicates t
      savehist-save-minibuffer-history 1
      savehist-additional-variables '(kill-ring
                                      search-ring
                                      regexp-search-ring))
(savehist-mode 1)

;; Counting 'recent files' as part of history
(use-package recentf :ensure t :defer t
  :config
  (setq recentf-max-saved-items 200
        recentf-max-menu-items 15)
  (recentf-mode))

;; Always save the desktop, the current workspace config
(setq desktop-path (list user-emacs-directory)
      desktop-auto-save-timeout 600
      desktop-restore-frames nil) ; desktop-store-frames will keep themes loaded
(desktop-save-mode 1)

;; Reload when file changed on disk
(global-auto-revert-mode t)

;; Don't create lockfiles.  They're often a hassle
(setq create-lockfiles nil)
#+END_SRC

** Magit - Git in Emacs
#+BEGIN_SRC emacs-lisp
(use-package magit :ensure t :defer t
  :config
  (setq
   ;; Magit needs to call git multiple times
   ;; only refreshing the  buffer can improve performance
   magit-refresh-status-buffer nil
   ;; Emacs has its own version control.  We don't need to run both
   ;; as that'll be detrimental for performance
   vc-handled-backends (delq 'Git vc-handled-backends))
  :bind (("C-x g" . magit-status)))

(use-package forge
  :after magit)
#+END_SRC

A better magit status. Only show magit, and if the currently active file had changes, go to it's unstaged changes section.
#+begin_src emacs-lisp
(defun unpackaged/magit-status ()
  "Open a `magit-status' buffer and close the other window so only Magit is visible.
If a file was visited in the buffer that was active when this
command was called, go to its unstaged changes section."
  (interactive)
  (let* ((buffer-file-path (when buffer-file-name
                             (file-relative-name buffer-file-name
                                                 (locate-dominating-file buffer-file-name ".git"))))
         (section-ident `((file . ,buffer-file-path) (unstaged) (status))))
    (magit-status)
    (delete-other-windows)
    (when buffer-file-path
      (goto-char (point-min))
      (cl-loop until (when (equal section-ident (magit-section-ident (magit-current-section)))
                       (magit-section-show (magit-current-section))
                       (recenter)
                       t)
               do (condition-case nil
                      (magit-section-forward)
                    (error (cl-return (magit-status-goto-initial-section-1))))))))
#+end_src

* Editing
** General Editing Config
#+BEGIN_SRC emacs-lisp
(show-paren-mode 1)

(setq find-file-visit-truename t)

;; transparently open compressed files
(auto-compression-mode t)

;; Don't double-space sentences
(set-default 'sentence-end-double-space nil)

;; Use lettercase to determine words in camelcase text
(global-subword-mode 1)
(diminish 'subword)

;; expand region
(use-package expand-region :ensure t)
(global-set-key (kbd "C-=") 'er/expand-region)

;; If a region is selected, any 'insert' command (typing or yanking) will overwrite it, rather than inserting before.
(delete-selection-mode 1)

;; indent after newline
(global-set-key (kbd "RET") 'newline-and-indent)

;; Interactive editing...over word or region, C-; to edit. Just modify
;; the symbol, then repeat C-; to exit.
(use-package iedit :ensure t :defer t)
(global-set-key (kbd "C-;") 'iedit-mode)

;; snippets
(use-package yasnippet :demand t :defer t :diminish)
(when (fboundp 'yas-global-mode)
  (yas-global-mode +1))
(diminish 'yas-minor-mode)
(use-package yasnippet-snippets :demand t :defer t)

(add-hook 'before-save-hook 'delete-trailing-whitespace)

(global-set-key (kbd "C-S-SPC") 'cycle-spacing)
#+END_SRC

** Text filling (paragraph reflowing) and indentation
#+BEGIN_SRC emacs-lisp
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and make it into a single line of text."
  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))

(use-package aggressive-indent :ensure t :defer t
  :config (global-aggressive-indent-mode))
#+END_SRC

** Offer to create parent dirs if they do not exist
[[http://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/][From this blog]]
#+BEGIN_SRC emacs-lisp

(defun my-create-non-existent-directory ()
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions 'my-create-non-existent-directory)
#+END_SRC
** Header templates per filetype
Use ~auto-insert~ when in a new file of that kind to insert header.
#+BEGIN_SRC emacs-lisp
(setq auto-insert-alist
      '(((emacs-lisp-mode . "Emacs lisp mode") nil
         ";;; " (file-name-nondirectory buffer-file-name) " --- " _ "\n\n"
         ";;; Commentary:\n\n"
         ";;; Code:\n\n"
         "(provide '" (substring (file-name-nondirectory buffer-file-name) 0 -3) ")\n"
         ";;; " (file-name-nondirectory buffer-file-name) " ends here\n")
        ((c-mode . "C program") nil
         "/*\n"
         " * File: " (file-name-nondirectory buffer-file-name) "\n"
         " * Description: " _ "\n"
         " */\n\n")
        ((shell-mode . "Shell script") nil
         "#!/bin/bash\n\n"
         " # File: " (file-name-nondirectory buffer-file-name) "\n"
         " # Description: " _ "\n\n")
        ((org-mode . "Org mode") nil
        "#+TITLE: " (read-string "Title: ") "\n"
        "#+AUTHOR: Chris Davison\n"
        "#+EMAIL: c.jr.davison@gmail.com\n"
        "#+OPTIONS: toc:2 num:nil html-postamble:nil\n"
        "#+PROPERTY: header-args :tangle " (read-string "Tangle filename: ") "\n")
        ((python-mode . "Python") nil
         "#!/usr/bin/env python3")
        ((awk-mode . "Awk") nil
         "#!/usr/bin/awk -f"
         "{"
         "    /* ACTION */"
         "    $0"
         "}"
         "END { "
         "    /* AFTER-ACTION */"
         "}")
      ))
#+END_SRC
** Move files
#+begin_src emacs-lisp
(defun rename-this-buffer-and-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name))
        (read-file-name-function 'read-file-name-default))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (cond ((get-buffer new-name)
               (error "A buffer named '%s' already exists!" new-name))
              (t
               (rename-file filename new-name 1)
               (rename-buffer new-name)
               (set-visited-file-name new-name)
               (set-buffer-modified-p nil)
               (message "File '%s' successfully renamed to '%s'" name (file-name-nondirectory new-name))))))))

(defun delete-this-buffer-and-file (force)
  "Delete the file connected to this buffer and kill it, FORCE is universal argument."
  (interactive "P")
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "'%s' is not a file buffer" name)
      (when (or force (yes-or-no-p (format  "Delete '%s', Are you sure? " filename)))
        (delete-file filename)
        (kill-buffer buffer)
        (message "Deleted '%s'" filename)))))
#+end_src
** Multiple cursors
Use multiple cursors

#+BEGIN_SRC emacs-lisp :tangle no
(use-package multiple-cursors :ensure t :defer t
  :hook ((prog-mode . multiple-cursors-mode)))
#+END_SRC

** Clear modification flag after saving
This is a bit of a hack to get around my current problem of the modification flag staying set, even after saving, meaning I need to visit buffers and manually toggle.

This function is just a wrapper around ~save-buffer~, to follow that call with a modification flag clear.

#+BEGIN_SRC emacs-lisp
(defun save-buffer-and-clear-modify ()
  (interactive)
  (save-buffer)
  (set-buffer-modified-p nil))
(global-set-key (kbd "C-x C-s") 'save-buffer-and-clear-modify)
#+END_SRC
** Undo Tree - Visualise branches of undos
People often struggle with the Emacs undo model, where there's really no concept of "redo" - you simply undo the undo.

This lets you use =C-x u= (=undo-tree-visualize=) to visually walk through the changes you've made, undo back to a certain point (or redo), and go down different branches.

#+BEGIN_SRC emacs-lisp :tangle no
(use-package undo-tree :ensure t :defer t :diminish
  :config
  (global-undo-tree-mode)
  (setq undo-tree-visualizer-timestamps nil
        undo-tree-visualizer-diff t))
#+END_SRC

* isearch -- live preview of search and replace
#+BEGIN_SRC emacs-lisp
;; Show current and total matches while searching
(use-package anzu :defer t :ensure t :diminish
  ;; Replace and regexp-replace are inverted, as I regexp-replace more
  :bind (([remap query-replace] . anzu-query-replace-regexp)
         ([remap query-replace-regexp] . anzu-query-replace))
  :config (global-anzu-mode t))

;; DEL during isearch should edit the search string, not jump back to the previous result
(define-key isearch-mode-map [remap isearch-delete-char] 'isearch-del-char)

(setq search-whitespace-regexp "[ \t\r\n-_]+")
#+END_SRC

* Terminal Improvements
** Windows Shell Config
Use git-bash as windows shell
#+BEGIN_SRC emacs-lisp
(defun cd/set-windows-shell ()
  "If on windows, set the shell to git bash."
  (interactive)
  (when (eq system-type 'windows-nt)
    (progn (setq explicit-shell-file-name
                 "C:/Program Files/Git/bin/sh.exe"
                 shell-file-name "bash"
                 explicit-sh.exe-args '("--login" "-i"))
           (setenv "SHELL" shell-file-name)
           (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m))))

(cd/set-windows-shell)
#+END_SRC
** Improvements for ansi-term
#+BEGIN_SRC emacs-lisp
(defadvice term-sentinel (around my-advice-term-sentinel (proc msg))
  "Close an ansi-term buffer if I quit the terminal."
  (if (memq (process-status proc) '(signal exit))
      (let ((buffer (process-buffer proc)))
        ad-do-it
        (kill-buffer buffer))
    ad-do-it))
(ad-activate 'term-sentinel)

;; By default, use fish in ansi-term
;; e.g. don't prompt for a shell
(defvar my-term-shell "/usr/local/bin/zsh")
(defadvice ansi-term (before force-bash)
  (interactive (list my-term-shell)))
(ad-activate 'ansi-term)

;; Use UTF8 in terminals
(defun my-term-use-utf8 ()
  (set-buffer-process-coding-system 'utf-8-unix 'utf-8-unix))
(add-hook 'term-exec-hook 'my-term-use-utf8)

;; Make URLs in the term clickable
(defun my-term-paste (&optional string)
  (interactive)
  (process-send-string
   (get-buffer-process (current-buffer))
   (if string string (current-kill 0))))

(defun my-term-hook ()
  (goto-address-mode)
  (define-key term-raw-map "\C-y" 'my-term-paste))
(add-hook 'term-mode-hook 'my-term-hook)
#+END_SRC

* PROGRAMMING LANGUAGES
** Completion (for multiple languages)
Company will *COMP*lete *ANY*thing.

#+BEGIN_SRC emacs-lisp
(use-package company-try-hard :ensure t :defer t)
(use-package company :ensure t :defer t :diminish
  :bind (("TAB" . company-indent-or-complete-common)
         ("M-4" . company-ispell)
         :map company-active-map
         ("C-z" . company-try-hard))
  :config
  (setq company-tooltip-align-annotations t
        company-idle-delay 0.5
        company-minimum-prefix-length 3
        company-backends (list 'company-files
                               'company-anaconda
                               ;; 'company-racer
                               'company-clang
                               'company-ispell
                               'company-yasnippet
                               'company-dabbrev-code
                               'company-dabbrev)))
(add-hook 'after-init-hook 'global-company-mode)

(use-package company-quickhelp :ensure t :defer t
  :config (company-quickhelp-mode))

;; (use-package company-racer :ensure t :defer t)

(defvar my/company-point nil)
(advice-add 'company-complete-common :before
            (lambda () (setq my/company-point (point))))
(advice-add 'company-complete-common :after
            (lambda ()
              (when (equal my/company-point (point))
                (yas-expand))))

(add-hook 'org-mode-hook '(lambda () (add-to-list 'company-backends 'company-ispell)))
#+END_SRC
** Syntax/error checking/linting, on the /fly/ (flycheck)
Flycheck basically runs linters and stuff, and lets you know problems in your code.
#+BEGIN_SRC emacs-lisp
  (use-package flycheck :ensure t :defer t
    :config
    (setq-default
     flycheck-disabled-checkers
     (append flycheck-disabled-checkers '(javascript-jshint) '(json-jsonlist))
     flycheck-temp-prefix ".flycheck")
    (flycheck-add-mode 'javascript-eslint 'web-mode)
    (add-hook 'after-init-hook #'global-flycheck-mode))
#+END_SRC
** Markdown
#+BEGIN_SRC emacs-lisp
(use-package markdown-mode :ensure t :defer t
  :config
  (add-to-list 'auto-mode-alist
               (cons "\\.\\(md\\|markdown\\)\\'" 'markdown-mode))
  (add-hook 'markdown-mode-hook 'visual-line-mode))
#+END_SRC
** Go
#+BEGIN_SRC emacs-lisp
(use-package go-mode :ensure t :defer t
  :config
  (add-hook 'before-save-hook 'gofmt-before-save)
  (setq gofmt-command "goimports"))
#+END_SRC
** Rust / Racer config
Auto-completion for rust, using racer
#+BEGIN_SRC emacs-lisp
(use-package rust-mode :ensure t :defer t)
(use-package flymake-rust :ensure t :defer t)
(use-package flycheck-rust :ensure t :defer t)
(use-package cargo :ensure t :defer t)
(use-package racer :defer t :ensure t)
(add-hook 'rust-mode-hook 'racer-mode)
(add-hook 'rust-mode-hook 'company-mode)
(add-hook 'racer-mode-hook 'eldoc-mode)
(add-hook 'rust-mode-hook 'cargo-minor-mode)
(add-hook 'racer-mode-hook 'company-mode)
(add-hook 'rust-mode-hook '(lambda () (add-to-list 'company-backends 'company-racer)))
#+END_SRC
** Python
Use elpy for python
#+BEGIN_SRC emacs-lisp
(use-package pyvenv :ensure t :defer t)
(use-package anaconda-mode :ensure t :defer t)
(add-hook 'python-mode-hook 'anaconda-mode)
(use-package company-anaconda :ensure t :defer t)
(eval-after-load "company" '(add-to-list 'company-backends 'company-anaconda))
(setq-default python-indent-offset 4)

(defun ipython()
  (interactive)
  (if (eq system-type 'windows-nt)
      (progn (setq explicit-shell-file-name
                   "C:/python3/scripts/ipython.exe")
             (setq shell-file-name "ipython")
             (setq explicit-sh.exe-args '("--login" "-i"))
             (setenv "SHELL" shell-file-name)
             (add-hook 'comint-output-filter-functions 'comint-strip-ctrl-m)
             (shell)
             (cd/set-windows-shell))
    (ansi-term "~/.envs/ml/bin/ipython" "ipython")))

(if (eq system-type 'windows-nt)
    (when (boundp 'python-shell-exec-path)
      (add-to-list 'python-shell-exec-path "c:/ProgramData/Miniconda3/"))
  (when (boundp 'python-shell-exec-path)
    (add-to-list 'python-shell-exec-path "~/.envs/ml/bin/")))
#+END_SRC
** TODO Latex
#+BEGIN_SRC emacs-lisp :tangle no
  (use-package auctex :ensure t :defer t
    :config
    (setq TeX-auto-save t
          TeX-parse-self t
          TeX-save-query nil
          ispell-program-name "aspell"
          ispell-dictionary "english")
    :hook ((LaTeX-mode . flyspell-mode)
           (LaTeX-mode . flyspell-buffer)
           (LaTeX-mode . outline-minor-mode)
           (LaTeX-mode . visual-line-mode)
           (LaTeX-mode . turn-on-reftex)))

  ;; Manage citations
  ;; (require 'tex-site)
  ;; (autoload 'reftex-mode "reftex" "RefTeX Minor Mode" t)
  ;; (autoload 'turn-on-reftex "reftex" "RefTeX Minor Mode" nil)
  ;; (autoload 'reftex-citation "reftex-cite" "Make citation" nil)
  ;; (autoload 'reftex-index-phrase-mode "reftex-index" "Phrase Mode" t)

  ;; (setq LaTeX-eqnarray-label "eq"
  ;;       LaTeX-equation-label "eq"
  ;;       LaTeX-figure-label "fig"
  ;;       LaTeX-table-label "tab"
  ;;       LaTeX-myChapter-label "chap"
  ;;       TeX-auto-save t
  ;;       TeX-newline-function 'reindent-then-newline-and-indent
  ;;       TeX-parse-self t
  ;;       TeX-style-path '("style/" "auto/"
  ;;                        "/usr/share/emacs21/site-lisp/auctex/style/"
  ;;                        "/var/lib/auctex/emacs21/"
  ;;                        "/usr/local/share/emacs/site-lisp/auctex/style/")
  ;;       LaTeX-section-hook '(LaTeX-section-heading
  ;;                            LaTeX-section-title
  ;;                            LaTeX-section-toc
  ;;                            LaTeX-section-section
  ;;                            LaTeX-section-label))
#+END_SRC
** Web-stuff
#+BEGIN_SRC emacs-lisp
(use-package sass-mode :ensure t :defer t)
(use-package js2-mode :ensure t :defer t)

;; Colourize CSS literals
;; (use-package rainbow-mode :ensure t :defer t
;;   :config
;;   (add-hook 'css-mode-hook 'rainbow-mode)
;;   (add-hook 'html-mode-hook 'rainbow-mode)
;;   (add-hook 'sass-mode-hook 'rainbow-mode))
#+END_SRC
** TODO Elixir
#+begin_src emacs-lisp :tangle no
(use-package alchemist :ensure t)
#+end_src
** TODO Julia
#+BEGIN_SRC emacs-lisp :tangle no
(use-package julia-mode :ensure t :defer t)
(use-package julia-repl :ensure t :defer t
  :config
  (add-hook 'julia-mode-hook 'julia-repl-mode))

(add-to-list 'load-path "C:/Julia-1.1.0/bin")
(if (eq system-type 'windows-nt)
    (setq julia-repl-executable-records '((default "julia.exe" :basedir "C:/Julia-1.1.0/bin" ))))

;; (setq julia-repl-executable-records '((default "julia")))
#+END_SRC
** TODO LISP -- Clojure and Cider
#+BEGIN_SRC emacs-lisp :tangle no
;; Cider for interactive clojure programming
(use-package flycheck-clojure :ensure t :defer t)
(use-package cider :ensure t :defer t
  :config
  (setq nrepl-popup-stacktraces nil)
  (with-eval-after-load 'cider
    (add-hook 'cider-mode-hook 'eldoc-mode)
    (add-hook 'cider-repl-mode-hook 'subword-mode)
    (add-hook 'cider-repl-mode-hook 'smartparens-mode)
    (add-hook 'cider-repl-mode-hook 'paredit-mode)
    (with-eval-after-load 'clojure-mode
      (with-eval-after-load 'flycheck
        (flycheck-clojure-setup)))))
#+END_SRC

* Navigation (windows, menus, buffers)
** Ivy (counsel, swiper, ivy) for navigation most menu-type things
Navigation of pretty much any /menu-type/ thing.

- =Ivy= and =counsel= make things like ~M-x~ and grep easier.
- =swiper= is a popup search of the current buffer.
- =imenu-anywhere= will search for headings/functions recursively over all files of the same /mode/

#+BEGIN_SRC emacs-lisp
(use-package ivy :ensure t :defer t :diminish
  :bind (:map ivy-mode-map
			  ("C-c h" . ivy-switch-buffer)
			  ("C-x b" . ivy-switch-buffer)
			  ("C-c s" . swiper))
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t
		ivy-height 15
		ivy-count-format ""
		ivy-initial-inputs-alist nil
		ivy-re-builders-alist '((t . ivy--regex-plus))))

(use-package counsel :ensure t :defer t
  :bind*
  (("C-x f" . counsel-find-file)
   ("C-c i" . counsel-imenu)
   ("C-c a" . counsel-rg)
   ("C-c g s" . counsel-grep-or-swiper)
   ("C-c b" . counsel-descbinds)
   ("M-x" . counsel-M-x))
  :config
  (setq counsel-grep-base-command
		"rg -i -M 120 --no-heading --line-number --color never '%s' %s"))

(use-package swiper :ensure t :defer t)
(use-package imenu-anywhere :ensure t :defer t)

(use-package dumb-jump :ensure t
  :config
  (add-hook 'prog-mode-hook 'dumb-jump-mode))

(use-package avy :ensure t :defer t)
(global-set-key (kbd "C-:") 'avy-goto-char-2)
#+END_SRC
** Switch between windows
Give HUD prompt when changing window, and keybind to cycle through windows.

#+BEGIN_SRC emacs-lisp
;; Prompt with a hud when switching windows, if more than 2 windows
(use-package switch-window :defer t
  :ensure t
  :bind ("C-x o" . switch-window))

;; cycle through 'windows' (e.g. panes)
(define-key global-map (kbd "M-`") 'next-multiframe-window)
(define-key global-map (kbd "C-M-`") 'previous-multiframe-window)
#+END_SRC

** ibuffer - view all open buffers
#+BEGIN_SRC emacs-lisp
;; Interactively modify buffer list
(use-package fullframe :ensure t :defer t)
(with-eval-after-load 'buffer (fullframe ibuffer ibuffer-quit))

(with-eval-after-load 'ibuffer
  ;; Use human readable Size column instead of original one
  (define-ibuffer-column size-h
    (:name "Size" :inline t)
    (cond
     ((> (buffer-size) 1000000) (format "%7.1fM" (/ (buffer-size) 1000000.0)))
     ((> (buffer-size) 1000) (format "%7.1fk" (/ (buffer-size) 1000.0)))
     (t (format "%8d" (buffer-size))))))

(global-set-key (kbd "C-x C-b") 'ibuffer)

(setq ibuffer-saved-filter-groups
      '(("home"
         ("Code" (filename . "code/"))
         ("Notes" (and
                         (mode . org-mode)
                         (filename . "Dropbox/notes/")))
         )))
(add-hook 'ibuffer-mode-hook '(lambda () (ibuffer-switch-to-saved-filter-groups "home")))
#+END_SRC

* OSX
#+BEGIN_SRC emacs-lisp
(when (eq system-type 'darwin)
  (use-package exec-path-from-shell :ensure t
    :config
    (when (memq window-system '(mac ns))
      (exec-path-from-shell-initialize))
    (exec-path-from-shell-copy-env "GOPATH"))

  (setq mac-command-modifier 'meta
        mac-option-modifier 'none
        default-input-method "MacOSX")
  (global-set-key (kbd "<f10>") 'toggle-frame-fullscreen))
#+END_SRC

* Org-mode
Org-mode is a really powerful notetaking tool.

You can easily /capture/ information using various different templates (including custom templates), and then refile them to perhaps a more appropriate location,

/Agenda/ lets you schedule and deadline tasks.
** General Org Config

#+BEGIN_SRC emacs-lisp
(defun cd/org-open-link-same ()
  (interactive)
  (let ((old-setup org-link-frame-setup))
    (setq org-link-frame-setup '((file . find-file)))
    (org-open-at-point)
    (setq org-link-frame-setup old-setup)))

(load-library "find-lisp")
(use-package org
  :ensure t
  :config
  (setq org-directory "~/Dropbox/notes"
        org-default-notes-file "~/Dropbox/notes/inbox.org"
        org-src-window-setup 'reorganize-frame
        org-agenda-window-setup 'only-window
        org-src-fontify-natively t
        org-src-tab-acts-natively t
        org-confirm-babel-evaluate nil
        org-pretty-entities t
        org-edit-src-content-indentation 0
        org-list-description-max-indent 5
        org-catch-invisible-edits 'show-and-error
        org-fontify-done-headline t
        org-insert-heading-respect-content t
        org-imenu-depth 3
        ;; Use M-+ M-- to change todo, and leave S-<arrow> for windows
        org-replace-disputed-keys t
        org-blank-before-new-entry '((heading . nil) (plain-list-item . auto))
        inhibit-compacting-font-caches t
        org-hide-emphasis-markers t
        org-todo-keywords'((sequence "TODO" "WIP" "|" "DONE")
                           (sequence "|" "DEAD"))
        org-agenda-skip-scheduled-if-done t
        org-agenda-start-with-log-mode t
        org-agenda-skip-deadline-prewarning-if-scheduled t
        org-startup-indented t
        org-hide-leading-stars t
        org-cycle-separator-lines 0
        org-list-indent-offset 1
        org-modules '(org-bibtex org-habit)
        org-agenda-files (find-lisp-find-files "~/Dropbox/notes" "\.org$")
        org-agenda-time-grid nil
        org-agenda-confirm-kill nil
        org-log-done nil
        org-log-repeat nil
        org-log-into-drawer nil
        org-log-done-with-time nil
        org-ellipsis "…"
        org-archive-location "~/Dropbox/notes/archive.org::")
  ;; Allow 2 newlines inside an org-mode 'emphasis' (e.g. bold or italic)
  (setcar (nthcdr 4 org-emphasis-regexp-components) 2)
  (org-babel-do-load-languages
   'org-babel-load-languages '((python . t)
                               (sqlite . t)
                               (emacs-lisp . t)))
  (setq org-confirm-babel-evaluate nil)
  ;; Settings for refiling
  (setq org-reverse-note-order t
        org-refile-use-outline-path nil
        org-outline-path-complete-in-steps nil
        org-refile-allow-creating-parent-nodes 'confirm
        org-refile-use-cache nil
        org-refile-targets '(
                             (org-agenda-files . (:maxlevel . 3))
                             ))
  (set-face-attribute 'org-block-begin-line nil :height 0.7 :slant 'normal)
  :hook ((org-mode . visual-line-mode)
         (org-mode . org-indent-mode)
         (org-mode . abbrev-mode)
         (org-mode . (lambda () (set-face-italic 'italic t)))))
;; Need ~htmlize~ so that I can export org buffers to HTML.
(use-package htmlize :ensure t :defer t)
(diminish 'abbrev-mode)
(diminish 'org-indent-mode)

(global-set-key (kbd "<f1>") '(lambda () (interactive) (progn (refresh-capture-templates) (org-capture))))
(global-set-key (kbd "<f2>") 'org-agenda)
(global-set-key (kbd "C-c l") 'org-store-link)
(global-set-key (kbd "C-c S-O") 'cd/org-open-link-same)
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package org-bullets :ensure t)
(add-hook 'org-mode-hook 'org-bullets-mode)
(setq  org-bullets-bullet-list
       '("①" "②" "③ " "④" "⑤" "⑥" "⑦" "⑧"))
#+END_SRC

** Fix indentation for org source blocks
#+BEGIN_SRC emacs-lisp
(defun cd/org-cleanup ()
  (interactive)
  (org-edit-special)
  (indent-region (point-min) (point-max))
  (org-edit-src-exit))
(global-set-key (kbd "C-x c") 'cd/org-cleanup)
#+END_SRC
** Templates for src/latex/etc blocks
#+BEGIN_SRC emacs-lisp
(setq org-structure-template-alist
      (if (string-greaterp (org-version) "9.2")
          '(("a" . "export ascii")
            ("c" . "center")
            ("C" . "comment")
            ("e" . "example")
            ("E" . "export")
            ("h" . "export html")
            ("l" . "src emacs-lisp")
            ("q" . "quote")
            ("s" . "src")
            ("v" . "verse")
            ("V" . "verbatim"))
        '(("a" "#+BEGIN_EXPORT ascii\n?\n#+END_EXPORT")
          ("c" "#+BEGIN_CENTER\n?\n#+END_CENTER")
          ("C" "#+BEGIN_COMMENT\n?\n#+END_COMMENT")
          ("e" "#+BEGIN_EXAMPLE\n?\n#+END_EXAMPLE")
          ("E" "#+BEGIN_EXPORT\n?\n#+END_EXPORT")
          ("h" "#+BEGIN_EXPORT html\n?\n#+END_EXPORT")
          ("l" "#+BEGIN_SRC emacs-lisp\n?\n#+END_SRC")
          ("q" "#+BEGIN_QUOTE\n?\n#+END_QUOTE")
          ("s" "#+BEGIN_SRC\n?\n#+END_SRC")
          ("v" "#+BEGIN_VERSE\n?\n#+END_VERSE")
          ("V" "#+BEGIN_VERBATIM\n?\n#+END_VERBATIM"))
        ))
#+END_SRC
** Move to prev/next narrow
#+BEGIN_SRC emacs-lisp
(defun cd/move-to-previous-narrow ()
  (interactive)
  (progn
    (beginning-of-buffer)
    (widen)
    (outline-previous-heading)
    (org-narrow-to-subtree)))

(defun cd/move-to-next-narrow ()
  (interactive)
  (progn
    (beginning-of-buffer)
    (widen)
    (outline-next-heading)
    (org-narrow-to-subtree)))
#+END_SRC
** Capture templates
#+BEGIN_SRC emacs-lisp
(setq cd-org-capture-templates
      `(
        ("t" "Todos")
        ("tt" "TASK TO REFILE" item (file "inbox.org")
         ("%^{TASK}") :empty-lines-before 1)
        ("ta" "Add to Anki" item (file"inbox.org")
         ("(ANKI) %^{Add to Anki}") :empty-lines-before 1)
        ("tt" "Buy" item (file "inbox.org")
         ("(BUY) %^{Buy}") :empty-lines-before 1)

        ("n" "Note" item (file "inbox.org") "%?")
        ("L" "link" item (file "inbox.org") "[[%^{URL}][%^{Description}]] %?")

        ("l" "Logbook" item
         (file+headline ,(format-time-string "logbook-%Y.org") ,(format-time-string "%Y-%m-%d %a"))
         "%?")

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ("g" "Games")
        ("gp" "PC" entry (file+headline "gaming.org" "PC")
         "* %^{Todo|TODO|WAIT|BUY|NEXT|PLAYING|DONE} %^{PC game}\n:%?")
        ("gn" "Nintendo Switch" entry (file+headline "gaming.org" "Nintendo Switch")
         "* %^{Todo|TODO|WAIT|BUY|NEXT|PLAYING|DONE} %^{Nintendo Switch game}\n:%?\n")
        ("gt" "Tabletop" entry (file+headline "gaming.org" "Tabletop")
         "* %^{Todo|TODO|BUY} %^{Tabletop game}\n%?\n")

        ("f" "Film" item (file "films-to-watch.org") "%^{Film} (%^{YEAR})\n")

        ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
        ("c" "Calendar" entry (file+headline "calendar.org" "Calendar")
         "* TODO %^t %^{EVENT}")

        ("Q" "Quote" entry (file "quotes.org")
         "* %^{Quote Topic} :quote:\n#+BEGIN_QUOTE\n%^{Quote} (%^{Author})\n#+END_QUOTE")

        ("a" "Article" entry (file+headline "academic-literature.org" "UNFILED")
         "* TODO %^{Article}\n%u\n\nAbstract: %?")))

(defun refresh-capture-templates ()
  (interactive)
  (setq org-capture-templates cd-org-capture-templates))
(refresh-capture-templates)
#+END_SRC
** Update checkboxes on save
#+BEGIN_SRC emacs-lisp :tangle no
(defun custom_org_auto_check()
  (org-update-checkbox-count t))
(add-hook 'org-mode-hook
          (lambda ()
             (add-hook 'after-save-hook 'custom_org_auto_check)))
#+END_SRC
** Agenda view WITHOUT archived
#+BEGIN_SRC emacs-lisp :tangle no
(setq org-agenda-custom-commands
      '(
        ("1" "Today"
         ((agenda "" ((org-agenda-span 1)))))
        ("2" "Two days"
         ((agenda "" ((org-agenda-span 2)))))
        ("3" "Three days"
         ((agenda "" ((org-agenda-span 3)))))

        ("w" . "Work Schedules")
        ("ww" "Work and Thesis"
         ((todo "TODO|WIP" ((org-agenda-files '("~/Dropbox/notes/work.org" "~/Dropbox/notes/thesis.org"))))))
        ("wu" "Unscheduled Work and Thesis"
         ((todo ""
                ((org-agenda-overriding-header "\nUnscheduled Work and Thesis")
                 (org-agenda-skip-function '(org-agenda-skip-entry-if 'scheduled))
                 (org-agenda-files
                  '("~/Dropbox/notes/work.org"p "~/Dropbox/notes/thesis.org"))))
          nil
          nil))

        ("ngt" "Non-gaming Todos"
         ((todo "TODO|WIP" ((org-agenda-overriding-header "Non-gaming Todos")
                            (org-agenda-files
                             (seq-filter
                              (lambda (x) (not (string-match "gaming" x)))
                              (file-expand-wildcards "~/Dropbox/notes/*.org"))
                             )))))))

(global-set-key
 (kbd "<f3>")
 '(lambda () (interactive) (org-agenda nil "3")))
#+END_SRC
** Enable drag-and-drop of files into org-files
This package lets you drag and drop stuff into org-mode files, copying (or downloading, if a web resource) into the relevant directory.

In this case, I've set it up to copy to a local 'assets' folder.  If ~org-download-heading-lvl~ is non-nil, it would create a subfolder based on the Nth heading.
#+BEGIN_SRC emacs-lisp
(use-package org-download :ensure t :defer t
  :config
  (setq-default org-download-image-dir "./assets")
  (setq-default org-download-heading-lvl nil))
(add-hook 'dired-mode-hook 'org-download-enable)
#+END_SRC
** Refile to a specific file

This is a general helper function that will refile the subtree at point to a specific file.  I use this along with hydra to let me refile to a few default locations. If called from a script (e.g. ~(refile-to-file "~/Dropbox/work.org")~, it'll set work to be the /only/ refile target. Otherwise, it'll prompt for a file (using a proper file dialog), and then only refile within that file.

#+BEGIN_SRC emacs-lisp
(defun refile-to-file (&optional target)
  (interactive)
  (let ((filename (or target (read-file-name "Refile to: ")))
        (old-refile-targets org-refile-targets))
    (progn (setq org-refile-targets `((filename . (:maxlevel . 6))))
           (org-refile)
           (setq org-refile-targets old-refile-targets))))

(defun refile-to-this-file ()
  (interactive)
  (refile-to-file (buffer-name)))
#+END_SRC
** Custom keybind functions
#+BEGIN_SRC emacs-lisp
(defun org-insert-indented-header ()
  (interactive)
  (org-insert-heading-respect-content)
  (org-do-demote))
(define-key org-mode-map (kbd "C-M-<return>") 'org-insert-indented-header)
#+END_SRC
** Reset all checkboxes in a repeating todo when the state change is toggled through ~DONE~
#+BEGIN_SRC emacs-lisp
(defun glasser-org-reset-check-on-repeat ()
  (when (and (org-get-repeat) (member org-state org-done-keywords))
    (org-reset-checkbox-state-subtree)))
(add-hook 'org-after-todo-state-change-hook 'glasser-org-reset-check-on-repeat)
#+END_SRC

** Mark a tree as DONE if it's TODO and all children are DONE
If a tree has a todo state and TODO children, then mark it as done when all children are done.
#+BEGIN_SRC emacs-lisp
(defun org-summary-todo (n-done n-not-done)
  "Switch entry to DONE when all subentries are done."
  (let (org-log-done org-log-states) ; turn off logging
    (org-todo (if (= n-not-done 0) "DONE" (if (> n-done 0) "WIP" "TODO")))))
(add-hook 'org-after-todo-statistics-hook 'org-summary-todo)
#+END_SRC
** Refile a subtree to a new file (with filename prompt)
#+BEGIN_SRC emacs-lisp
(require 'org-element)

(defun org-file-from-subtree (&optional name)
  "Cut the subtree currently being edited and create a new file
from it.

If called with the universal argument, prompt for new filename,
otherwise use the subtree title"
  (interactive "P")
  (let ((filename (expand-file-name (read-file-name "New file name:"))))
    (org-cut-subtree)
    (find-file-noselect filename)
    (with-temp-file filename
      (org-mode)
      (yank))
    (find-file filename)))
(define-key org-mode-map (kbd "C-x C-n") 'org-file-from-subtree)
#+END_SRC

* Hydra -- General utility HUDs
#+BEGIN_SRC emacs-lisp
(use-package hydra :ensure t :defer t)

(defhydra cd/hydra/windowmove (:exit t)
  ("r" (progn (split-window-right) (windmove-right)) "Split right")
  ("d" (progn (split-window-below) (windmove-down)) "Split down")
  ("R" rotate-layout "Rotate Layout" :exit nil)
  ("n" cd/move-to-next-narrow "Next narrow" :exit nil)
  ("p" cd/move-to-previous-narrow "Prev narrow" :exit nil)
  ("o" other-frame "Other window")
  (">" indent-rigidly-right-to-tab-stop "Indent" :exit nil)
  ("<" indent-rigidly-left-to-tab-stop "De-dent" :exit nil))

(defhydra cd/hydra/main (:exit t :columns 3)
  ("z" (modi/toggle-one-window nil) "zoom")
  ("C-z" company-try-hard "Company TryHard")
  ("w" cd/hydra/windowmove/body "WINDOW")
  ("s" counsel-grep-or-swiper "search")
  ("S" ispell-word "Spell")
  ("g" deadgrep "grep")
  ("r" anzu-query-replace-regexp "replace")
  ("i" ivy-imenu-anywhere "imenu")
  ("e" iedit-mode "iedit")
  ("j" avy-goto-word-1 "Jump to word")
  ("o" cd/org-open-link-same "org-open")
  ("O" org-mark-ring-goto "Return from link")
  ("<up>" delete-indentation "join-up" :exit nil )
  ("<down>" (join-line -1) "join-down" :exit nil ))
(define-key global-map (kbd "C-z") 'cd/hydra/main/body)
#+END_SRC

* Appearance
** Handle the fonts I like
List some pretty fonts, and grab the first one that's available.
#+BEGIN_SRC emacs-lisp
(setq cd-fonts
      (cl-remove-if (lambda (font) (not (member font (font-family-list))))
                    '("CamingoCode" "Roboto Mono" "Ubuntu Mono" "Liberation Mono" "Fira Code")))
(when cd-fonts
  (set-frame-font (car cd-fonts) 1))

(defun set-pretty-font ()
  "Set a font from one of the available fonts that I like"
  (interactive)
  (set-frame-font (ivy-read "Pick font:" cd-fonts) 1))

(defvar current-font-idx 0)
(defun next-font ()
  (interactive)
  (setq current-font-idx
        (% (+ 1 current-font-idx)
           (length cd-fonts)))
  (let ((next-font-name (nth current-font-idx cd-fonts)))
    (set-frame-font next-font-name 1)
    (message next-font-name)))

(setq line-spacing 0.2)
(set-face-attribute 'default nil :height (if (eq system-type 'windows-nt) 140 200))
(setq auto-window-vscroll nil)
#+END_SRC

** Colour themes

Disable themes before loading a new theme.  This can cause some issues when using things like 'powerline', as powerline is technically a theme.  Because smart-mode-line was later in my emacs config, my actual colour theme ended up getting disabled.  Disabling this for now until I decide if I really need it.
#+BEGIN_SRC emacs-lisp
(defadvice load-theme (before theme-dont-propagate activate)
  (disable-all-themes))

(defadvice load-theme (after run-after-load-theme-hook activate)
  (set-face-italic 'italic t))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun disable-all-themes ()
  (interactive)
  (mapc 'disable-theme custom-enabled-themes))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(setq custom-safe-themes t)    ;; themes are 'safe'
(use-package doneburn-theme)
(use-package darkokai-theme)
(use-package doom-themes)
(use-package doom-modeline :ensure t)

(load-theme 'doneburn t)
(doom-modeline-mode)
;; (load-theme 'darkokai t)
#+END_SRC
** Suppress GUI features
#+BEGIN_SRC emacs-lisp
(setq use-file-dialog nil
      use-dialog-box nil
      menu-bar-mode nil
      inhibit-startup-screen t
      inhibit-startup-echo-area-message t)
(add-hook 'after-init-hook '(lambda () (menu-bar-mode -1)))

;; Hide tool bar,  scroll bar and borders
(when (fboundp 'tool-bar-mode) (tool-bar-mode -1))
(when (fboundp 'set-scroll-bar-mode) (set-scroll-bar-mode nil))

(let ((no-border '(internal-border-width . 0)))
  (add-to-list 'default-frame-alist no-border)
  (add-to-list 'initial-frame-alist no-border))
#+END_SRC

** Line highlighting, linum, colnum, and cursor
#+BEGIN_SRC emacs-lisp
(global-hl-line-mode 1)
(blink-cursor-mode 0)
(setq linum-format "%d ")

;; Line number and column
(line-number-mode 1)
(column-number-mode 1)
#+END_SRC
** Tabstop stuff
#+BEGIN_SRC emacs-lisp
(setq tab-stop-list (number-sequence 4 200 4))
(setq-default indent-tabs-mode nil)
(setq-default tab-width 4)
#+END_SRC
** Don't scroll jump multiple lines
#+BEGIN_SRC emacs-lisp
(setq scroll-step 1
      scroll-conservatively 10000)
#+END_SRC
** Temporary 'zoom' into a pane
A bit like 'focus mode' for other languages.  Can perhaps combine this with /darkroom/ to enforce distraction free writing.

From [[https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-windows-buffers.el][this github repo]].
#+BEGIN_SRC emacs-lisp
(defvar modi/toggle-one-window--buffer-name nil
  "Variable to store the name of the buffer for which the `modi/toggle-one-window'
function is called.")

(defvar modi/toggle-one-window--window-configuration nil
  "Variable to store the window configuration before `modi/toggle-one-window'
function was called.")

(defun modi/toggle-one-window (&optional force-one-window)
  "Toggles the frame state between deleting all windows other than
the current window and the windows state prior to that."
  (interactive "P")
  (if (or (null (one-window-p)) force-one-window)
      (progn
        (setq modi/toggle-one-window--buffer-name (buffer-name))
        (setq modi/toggle-one-window--window-configuration (current-window-configuration))
        (delete-other-windows))
    (progn
      (when modi/toggle-one-window--buffer-name
        (set-window-configuration modi/toggle-one-window--window-configuration)
        (switch-to-buffer modi/toggle-one-window--buffer-name)))))
  (define-key global-map (kbd "C-x 1") 'modi/toggle-one-window)

#+END_SRC
** Code-folding
#+BEGIN_SRC emacs-lisp
;; Code folding
(use-package yafolding :ensure t)
(add-hook 'prog-mode-hook 'yafolding-mode)
(use-package fold-dwim :ensure t :defer t)
(use-package fold-dwim-org :ensure t :defer t)
(add-hook 'prog-mode-hook 'fold-dwim-org/minor-mode)
#+END_SRC
** OTHER appearance stuff
#+BEGIN_SRC emacs-lisp
(setq uniquify-buffer-name-style 'forward)
(setq linum-format "%4d ")

(set-default 'indicate-empty-lines t)

;; Soft-wrap at a column.
;; Not currently setting this globally, as still unsure about
;; hard wrap vs soft-wrap vs soft-wrap with ruler
(use-package visual-fill-column :ensure t :diminish
  :config
  (setq visual-fill-column-width 80))

;; Replace lambda and AND etc with pretty symbols
(global-prettify-symbols-mode +1)
(diminish 'visual-line-mode)
#+END_SRC

* TESTING GROUND
#+BEGIN_SRC emacs-lisp
(defun mydired-sort ()
  "Sort dired listings with directories first."
  (save-excursion
    (let (buffer-read-only)
      (forward-line 2) ;; beyond dir. header
      (sort-regexp-fields t "^.*$" "[ ]*." (point) (point-max)))
    (set-buffer-modified-p nil)))

(defadvice dired-readin
  (after dired-after-updating-hook first () activate)
  "Sort dired listings with directories first before adding marks."
  (mydired-sort))

(add-hook 'dired-mode-hook 'dired-hide-details-mode)
#+END_SRC

Better 'help' buffers
#+BEGIN_SRC emacs-lisp
(use-package helpful :ensure t :defer t
  :config (setq helpful-max-buffers 2))
(global-set-key (kbd "C-h f") #'helpful-callable)
(global-set-key (kbd "C-h v") #'helpful-variable)
(global-set-key (kbd "C-h k") #'helpful-key)
#+END_SRC

A nice interface to ripgrep (choose specific filetypes, directory etc...and 'occur'-like buffer)
#+BEGIN_SRC emacs-lisp
(use-package deadgrep :defer t)
#+END_SRC

Rotate between 'common' layouts (e.g. vertical to horizontal split)
#+BEGIN_SRC emacs-lisp
(use-package rotate :ensure t :defer t
  :bind (("C-c r" . rotate-layout)))
#+END_SRC

When double clicking a file, or launching from terminal, always use the same instance of Emacs, rather than opening a new frame.
#+BEGIN_SRC emacs-lisp
(setq ns-pop-up-frames nil)
#+END_SRC

Use a very narrow window border.
#+BEGIN_SRC emacs-lisp
(fringe-mode 1)
#+END_SRC


#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters :ensure t
  :hook ((prog-mode . rainbow-delimiters-mode)))
#+END_SRC

Simple function shortcuts to do an org-occur, or normal occur, for unticked checkboxes
#+BEGIN_SRC emacs-lisp
(defun checkboxes ()
  (interactive)
  (org-occur "\\[ \\]"))
(defun occur-checkboxes ()
  (interactive)
  (occur "\\[ \\]"))
#+END_SRC

Shortcut function to move all checked checkboxes to the top of the list
#+BEGIN_SRC emacs-lisp
(defun sort-checkboxes ()
  (interactive)
  (org-sort-list nil ?X))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(defun org-subtree-count-words ()
  (interactive)
  (progn
    (org-mark-subtree)
    (count-words-region (region-beginning) (region-end))))
#+END_SRC

#+BEGIN_SRC emacs-lisp
(use-package hide-lines :ensure t :defer t)
#+END_SRC
